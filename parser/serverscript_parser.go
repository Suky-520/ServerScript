// Code generated from /Users/lzp/代码/workspace_go/ss/parser/ServerScriptParser.g4 by ANTLR 4.13.1. DO NOT EDIT.

package parser // ServerScriptParser

import (
	"fmt"
	"strconv"
	"sync"

	"github.com/antlr4-go/antlr/v4"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = strconv.Itoa
var _ = sync.Once{}

type ServerScriptParser struct {
	ServerScriptParserBase
}

var ServerScriptParserParserStaticData struct {
	once                   sync.Once
	serializedATN          []int32
	LiteralNames           []string
	SymbolicNames          []string
	RuleNames              []string
	PredictionContextCache *antlr.PredictionContextCache
	atn                    *antlr.ATN
	decisionToDFA          []*antlr.DFA
}

func serverscriptparserParserInit() {
	staticData := &ServerScriptParserParserStaticData
	staticData.LiteralNames = []string{
		"", "", "", "", "", "'['", "']'", "'('", "')'", "'{'", "", "'}'", "';'",
		"','", "'='", "'?'", "'?.'", "':'", "'...'", "'.'", "'++'", "'--'",
		"'+'", "'-'", "'~'", "'!'", "'*'", "'/'", "'%'", "'**'", "'??'", "'#'",
		"'>>'", "'<<'", "'>>>'", "'<'", "'>'", "'<='", "'>='", "'=='", "'!='",
		"'==='", "'!=='", "'&'", "'^'", "'|'", "'&&'", "'||'", "'*='", "'/='",
		"'%='", "'+='", "'-='", "'<<='", "'>>='", "'>>>='", "'&='", "'^='",
		"'|='", "'**='", "'??='", "'=>'", "'null'", "'NaN'", "'undefined'",
		"", "'Infinity'", "", "", "", "", "", "", "", "", "", "'break'", "'do'",
		"'instanceof'", "'typeof'", "'case'", "'else'", "'new'", "'var'", "'let'",
		"'catch'", "'finally'", "'return'", "'void'", "'continue'", "'for'",
		"'switch'", "'while'", "'debugger'", "'function'", "'this'", "'with'",
		"'default'", "'if'", "'throw'", "'delete'", "'in'", "'try'", "'as'",
		"'from'", "'of'", "'class'", "'enum'", "'extends'", "'super'", "'const'",
		"'export'", "'import'", "'async'", "'sync'", "'await'", "'yield'", "'implements'",
		"'private'", "'public'", "'interface'", "'package'", "'protected'",
		"'static'", "", "", "", "", "", "", "", "", "'${'",
	}
	staticData.SymbolicNames = []string{
		"", "HashBangLine", "MultiLineComment", "SingleLineComment", "RegularExpressionLiteral",
		"OpenBracket", "CloseBracket", "OpenParen", "CloseParen", "OpenBrace",
		"TemplateCloseBrace", "CloseBrace", "SemiColon", "Comma", "Assign",
		"QuestionMark", "QuestionMarkDot", "Colon", "Ellipsis", "Dot", "PlusPlus",
		"MinusMinus", "Plus", "Minus", "BitNot", "Not", "Multiply", "Divide",
		"Modulus", "Power", "NullCoalesce", "Hashtag", "RightShiftArithmetic",
		"LeftShiftArithmetic", "RightShiftLogical", "LessThan", "MoreThan",
		"LessThanEquals", "GreaterThanEquals", "Equals_", "NotEquals", "IdentityEquals",
		"IdentityNotEquals", "BitAnd", "BitXOr", "BitOr", "And", "Or", "MultiplyAssign",
		"DivideAssign", "ModulusAssign", "PlusAssign", "MinusAssign", "LeftShiftArithmeticAssign",
		"RightShiftArithmeticAssign", "RightShiftLogicalAssign", "BitAndAssign",
		"BitXorAssign", "BitOrAssign", "PowerAssign", "NullishCoalescingAssign",
		"ARROW", "NullLiteral", "NaNLiteral", "UndefinedLiteral", "BooleanLiteral",
		"InfinityLiteral", "DecimalLiteral", "ExponentLiteral", "HexIntegerLiteral",
		"OctalIntegerLiteral", "BinaryIntegerLiteral", "BigHexIntegerLiteral",
		"BigOctalIntegerLiteral", "BigBinaryIntegerLiteral", "BigDecimalIntegerLiteral",
		"Break", "Do", "Instanceof", "Typeof", "Case", "Else", "New", "Var",
		"Let", "Catch", "Finally", "Return", "Void", "Continue", "For", "Switch",
		"While", "Debugger", "Function_", "This", "With", "Default", "If", "Throw",
		"Delete", "In", "Try", "As", "From", "Of", "Class", "Enum", "Extends",
		"Super", "Const", "Export", "Import", "Async", "Sync", "Await", "Yield",
		"Implements", "Private", "Public", "Interface", "Package", "Protected",
		"Static", "Identifier", "StringLiteral", "BackTick", "WhiteSpaces",
		"LineTerminator", "HtmlComment", "CDataComment", "UnexpectedCharacter",
		"TemplateStringStartExpression", "TemplateStringAtom",
	}
	staticData.RuleNames = []string{
		"program", "sourceElements", "sourceElement", "statement", "block",
		"statementList", "importStatement", "importFromBlock", "importModuleItems",
		"importAliasName", "moduleExportName", "importedBinding", "importDefault",
		"importNamespace", "importFrom", "aliasName", "exportStatement", "exportNamespace",
		"exportFromBlock", "exportModuleItems", "exportAliasName", "declaration",
		"variableStatement", "variableDeclarationList", "variableDeclaration",
		"emptyStatement_", "expressionStatement", "ifStatement", "ifBlock",
		"elseIfBlock", "elseBlock", "iterationStatement", "ofArrayLiteral",
		"identifierList", "forStatement1", "forStatement2", "forStatement3",
		"varModifier", "continueStatement", "breakStatement", "returnStatement",
		"switchStatement", "caseBlock", "caseClauses", "caseClause", "defaultClause",
		"throwStatement", "tryStatement", "catchProduction", "finallyProduction",
		"functionDeclaration", "formalParameterList", "formalParameterArg",
		"lastFormalParameterArg", "functionBody", "arrayLiteral", "elementList",
		"arrayElement", "propertyAssignment", "propertyName", "arguments", "argument",
		"expressionSequence", "singleExpression", "assignable", "objectLiteral",
		"anonymousFunction", "arrowFunctionParameters", "assignmentOperator",
		"literal", "templateStringLiteral", "templateStringAtom", "numericLiteral",
		"bigintLiteral", "identifierName", "identifier", "reservedWord", "keyword",
		"eos",
	}
	staticData.PredictionContextCache = antlr.NewPredictionContextCache()
	staticData.serializedATN = []int32{
		4, 1, 133, 889, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2, 4, 7,
		4, 2, 5, 7, 5, 2, 6, 7, 6, 2, 7, 7, 7, 2, 8, 7, 8, 2, 9, 7, 9, 2, 10, 7,
		10, 2, 11, 7, 11, 2, 12, 7, 12, 2, 13, 7, 13, 2, 14, 7, 14, 2, 15, 7, 15,
		2, 16, 7, 16, 2, 17, 7, 17, 2, 18, 7, 18, 2, 19, 7, 19, 2, 20, 7, 20, 2,
		21, 7, 21, 2, 22, 7, 22, 2, 23, 7, 23, 2, 24, 7, 24, 2, 25, 7, 25, 2, 26,
		7, 26, 2, 27, 7, 27, 2, 28, 7, 28, 2, 29, 7, 29, 2, 30, 7, 30, 2, 31, 7,
		31, 2, 32, 7, 32, 2, 33, 7, 33, 2, 34, 7, 34, 2, 35, 7, 35, 2, 36, 7, 36,
		2, 37, 7, 37, 2, 38, 7, 38, 2, 39, 7, 39, 2, 40, 7, 40, 2, 41, 7, 41, 2,
		42, 7, 42, 2, 43, 7, 43, 2, 44, 7, 44, 2, 45, 7, 45, 2, 46, 7, 46, 2, 47,
		7, 47, 2, 48, 7, 48, 2, 49, 7, 49, 2, 50, 7, 50, 2, 51, 7, 51, 2, 52, 7,
		52, 2, 53, 7, 53, 2, 54, 7, 54, 2, 55, 7, 55, 2, 56, 7, 56, 2, 57, 7, 57,
		2, 58, 7, 58, 2, 59, 7, 59, 2, 60, 7, 60, 2, 61, 7, 61, 2, 62, 7, 62, 2,
		63, 7, 63, 2, 64, 7, 64, 2, 65, 7, 65, 2, 66, 7, 66, 2, 67, 7, 67, 2, 68,
		7, 68, 2, 69, 7, 69, 2, 70, 7, 70, 2, 71, 7, 71, 2, 72, 7, 72, 2, 73, 7,
		73, 2, 74, 7, 74, 2, 75, 7, 75, 2, 76, 7, 76, 2, 77, 7, 77, 2, 78, 7, 78,
		1, 0, 3, 0, 160, 8, 0, 1, 0, 3, 0, 163, 8, 0, 1, 0, 1, 0, 1, 1, 4, 1, 168,
		8, 1, 11, 1, 12, 1, 169, 1, 2, 1, 2, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3,
		1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 3, 3, 189, 8, 3,
		1, 4, 1, 4, 3, 4, 193, 8, 4, 1, 4, 1, 4, 1, 5, 4, 5, 198, 8, 5, 11, 5,
		12, 5, 199, 1, 6, 1, 6, 1, 6, 1, 7, 3, 7, 206, 8, 7, 1, 7, 1, 7, 1, 7,
		1, 7, 1, 7, 3, 7, 213, 8, 7, 1, 7, 1, 7, 1, 7, 1, 7, 1, 7, 1, 7, 1, 7,
		1, 7, 3, 7, 223, 8, 7, 1, 8, 1, 8, 1, 8, 1, 8, 5, 8, 229, 8, 8, 10, 8,
		12, 8, 232, 9, 8, 1, 8, 1, 8, 3, 8, 236, 8, 8, 3, 8, 238, 8, 8, 1, 8, 1,
		8, 1, 9, 1, 9, 1, 9, 3, 9, 245, 8, 9, 1, 10, 1, 10, 3, 10, 249, 8, 10,
		1, 11, 1, 11, 1, 12, 1, 12, 1, 12, 1, 13, 1, 13, 1, 13, 1, 13, 1, 14, 1,
		14, 1, 14, 1, 15, 1, 15, 1, 15, 3, 15, 266, 8, 15, 1, 16, 1, 16, 1, 16,
		1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1,
		16, 1, 16, 1, 16, 1, 16, 3, 16, 285, 8, 16, 1, 17, 1, 17, 1, 17, 3, 17,
		290, 8, 17, 1, 18, 1, 18, 1, 18, 1, 18, 1, 19, 1, 19, 1, 19, 1, 19, 5,
		19, 300, 8, 19, 10, 19, 12, 19, 303, 9, 19, 1, 19, 1, 19, 3, 19, 307, 8,
		19, 3, 19, 309, 8, 19, 1, 19, 1, 19, 1, 20, 1, 20, 1, 20, 3, 20, 316, 8,
		20, 1, 21, 1, 21, 3, 21, 320, 8, 21, 1, 22, 1, 22, 1, 22, 1, 23, 1, 23,
		1, 23, 1, 23, 5, 23, 329, 8, 23, 10, 23, 12, 23, 332, 9, 23, 1, 24, 1,
		24, 1, 24, 3, 24, 337, 8, 24, 1, 25, 1, 25, 1, 26, 1, 26, 1, 26, 1, 26,
		1, 27, 1, 27, 5, 27, 347, 8, 27, 10, 27, 12, 27, 350, 9, 27, 1, 27, 3,
		27, 353, 8, 27, 1, 28, 1, 28, 1, 28, 1, 28, 1, 28, 1, 28, 1, 29, 1, 29,
		1, 29, 1, 29, 1, 29, 1, 29, 1, 29, 1, 30, 1, 30, 1, 30, 1, 31, 1, 31, 1,
		31, 1, 31, 1, 31, 1, 31, 1, 31, 1, 31, 1, 31, 1, 31, 1, 31, 1, 31, 1, 31,
		1, 31, 1, 31, 1, 31, 1, 31, 3, 31, 388, 8, 31, 1, 31, 1, 31, 3, 31, 392,
		8, 31, 1, 31, 1, 31, 3, 31, 396, 8, 31, 1, 31, 1, 31, 1, 31, 1, 31, 1,
		31, 1, 31, 1, 31, 3, 31, 405, 8, 31, 1, 31, 1, 31, 1, 31, 1, 31, 1, 31,
		3, 31, 412, 8, 31, 1, 32, 1, 32, 1, 32, 1, 32, 1, 33, 5, 33, 419, 8, 33,
		10, 33, 12, 33, 422, 9, 33, 1, 33, 3, 33, 425, 8, 33, 1, 33, 4, 33, 428,
		8, 33, 11, 33, 12, 33, 429, 1, 33, 5, 33, 433, 8, 33, 10, 33, 12, 33, 436,
		9, 33, 1, 33, 5, 33, 439, 8, 33, 10, 33, 12, 33, 442, 9, 33, 1, 34, 1,
		34, 3, 34, 446, 8, 34, 1, 35, 1, 35, 1, 36, 1, 36, 1, 37, 1, 37, 1, 38,
		1, 38, 1, 38, 3, 38, 457, 8, 38, 1, 38, 1, 38, 1, 39, 1, 39, 1, 39, 3,
		39, 464, 8, 39, 1, 39, 1, 39, 1, 40, 1, 40, 1, 40, 3, 40, 471, 8, 40, 1,
		40, 1, 40, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 42, 1, 42, 3, 42,
		483, 8, 42, 1, 42, 1, 42, 3, 42, 487, 8, 42, 3, 42, 489, 8, 42, 1, 42,
		1, 42, 1, 43, 4, 43, 494, 8, 43, 11, 43, 12, 43, 495, 1, 44, 1, 44, 1,
		44, 1, 44, 3, 44, 502, 8, 44, 1, 45, 1, 45, 1, 45, 3, 45, 507, 8, 45, 1,
		46, 1, 46, 1, 46, 1, 46, 1, 46, 1, 47, 1, 47, 1, 47, 1, 47, 3, 47, 518,
		8, 47, 1, 47, 3, 47, 521, 8, 47, 1, 48, 1, 48, 1, 48, 3, 48, 526, 8, 48,
		1, 48, 3, 48, 529, 8, 48, 1, 48, 1, 48, 1, 49, 1, 49, 1, 49, 1, 50, 1,
		50, 1, 50, 1, 50, 3, 50, 540, 8, 50, 1, 50, 1, 50, 1, 50, 1, 51, 1, 51,
		1, 51, 5, 51, 548, 8, 51, 10, 51, 12, 51, 551, 9, 51, 1, 51, 1, 51, 3,
		51, 555, 8, 51, 1, 51, 3, 51, 558, 8, 51, 1, 52, 1, 52, 1, 52, 3, 52, 563,
		8, 52, 1, 53, 1, 53, 1, 53, 1, 54, 1, 54, 3, 54, 570, 8, 54, 1, 54, 1,
		54, 1, 55, 1, 55, 1, 55, 1, 55, 1, 56, 5, 56, 579, 8, 56, 10, 56, 12, 56,
		582, 9, 56, 1, 56, 3, 56, 585, 8, 56, 1, 56, 4, 56, 588, 8, 56, 11, 56,
		12, 56, 589, 1, 56, 5, 56, 593, 8, 56, 10, 56, 12, 56, 596, 9, 56, 1, 56,
		5, 56, 599, 8, 56, 10, 56, 12, 56, 602, 9, 56, 1, 57, 3, 57, 605, 8, 57,
		1, 57, 1, 57, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1,
		58, 1, 58, 1, 58, 3, 58, 620, 8, 58, 1, 58, 1, 58, 1, 58, 3, 58, 625, 8,
		58, 1, 58, 1, 58, 1, 58, 1, 58, 3, 58, 631, 8, 58, 1, 58, 3, 58, 634, 8,
		58, 1, 59, 1, 59, 1, 59, 1, 59, 1, 59, 1, 59, 1, 59, 3, 59, 643, 8, 59,
		1, 60, 1, 60, 1, 60, 1, 60, 5, 60, 649, 8, 60, 10, 60, 12, 60, 652, 9,
		60, 1, 60, 3, 60, 655, 8, 60, 3, 60, 657, 8, 60, 1, 60, 1, 60, 1, 61, 3,
		61, 662, 8, 61, 1, 61, 1, 61, 3, 61, 666, 8, 61, 1, 62, 1, 62, 1, 62, 5,
		62, 671, 8, 62, 10, 62, 12, 62, 674, 9, 62, 1, 63, 1, 63, 1, 63, 1, 63,
		1, 63, 3, 63, 681, 8, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1,
		63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63,
		1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1,
		63, 1, 63, 3, 63, 712, 8, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63,
		1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1,
		63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63,
		1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1,
		63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 3, 63, 759, 8, 63,
		1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 3, 63, 770,
		8, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 5,
		63, 781, 8, 63, 10, 63, 12, 63, 784, 9, 63, 1, 64, 1, 64, 1, 64, 3, 64,
		789, 8, 64, 1, 65, 1, 65, 1, 65, 1, 65, 5, 65, 795, 8, 65, 10, 65, 12,
		65, 798, 9, 65, 1, 65, 3, 65, 801, 8, 65, 3, 65, 803, 8, 65, 1, 65, 1,
		65, 1, 66, 1, 66, 3, 66, 809, 8, 66, 1, 66, 1, 66, 3, 66, 813, 8, 66, 1,
		66, 1, 66, 1, 66, 1, 66, 1, 66, 1, 66, 1, 66, 1, 66, 1, 66, 1, 66, 3, 66,
		825, 8, 66, 1, 67, 1, 67, 1, 67, 3, 67, 830, 8, 67, 1, 67, 3, 67, 833,
		8, 67, 1, 68, 1, 68, 1, 69, 1, 69, 1, 69, 1, 69, 1, 69, 1, 69, 1, 69, 1,
		69, 1, 69, 1, 69, 3, 69, 847, 8, 69, 1, 70, 1, 70, 5, 70, 851, 8, 70, 10,
		70, 12, 70, 854, 9, 70, 1, 70, 1, 70, 1, 71, 1, 71, 1, 71, 1, 71, 1, 71,
		3, 71, 863, 8, 71, 1, 72, 1, 72, 1, 73, 1, 73, 1, 74, 1, 74, 1, 74, 3,
		74, 872, 8, 74, 1, 75, 1, 75, 1, 76, 1, 76, 1, 76, 3, 76, 879, 8, 76, 1,
		77, 1, 77, 1, 78, 1, 78, 1, 78, 1, 78, 3, 78, 887, 8, 78, 1, 78, 0, 1,
		126, 79, 0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32,
		34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68,
		70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104,
		106, 108, 110, 112, 114, 116, 118, 120, 122, 124, 126, 128, 130, 132, 134,
		136, 138, 140, 142, 144, 146, 148, 150, 152, 154, 156, 0, 16, 2, 0, 115,
		116, 124, 124, 2, 0, 84, 84, 110, 110, 1, 0, 113, 114, 1, 0, 26, 28, 1,
		0, 22, 23, 1, 0, 32, 34, 1, 0, 35, 38, 1, 0, 39, 42, 1, 0, 43, 45, 1, 0,
		46, 47, 2, 0, 16, 16, 19, 19, 1, 0, 48, 60, 1, 0, 67, 71, 1, 0, 72, 75,
		4, 0, 103, 105, 113, 113, 116, 116, 124, 124, 1, 0, 76, 123, 970, 0, 159,
		1, 0, 0, 0, 2, 167, 1, 0, 0, 0, 4, 171, 1, 0, 0, 0, 6, 188, 1, 0, 0, 0,
		8, 190, 1, 0, 0, 0, 10, 197, 1, 0, 0, 0, 12, 201, 1, 0, 0, 0, 14, 222,
		1, 0, 0, 0, 16, 224, 1, 0, 0, 0, 18, 241, 1, 0, 0, 0, 20, 248, 1, 0, 0,
		0, 22, 250, 1, 0, 0, 0, 24, 252, 1, 0, 0, 0, 26, 255, 1, 0, 0, 0, 28, 259,
		1, 0, 0, 0, 30, 262, 1, 0, 0, 0, 32, 284, 1, 0, 0, 0, 34, 286, 1, 0, 0,
		0, 36, 291, 1, 0, 0, 0, 38, 295, 1, 0, 0, 0, 40, 312, 1, 0, 0, 0, 42, 319,
		1, 0, 0, 0, 44, 321, 1, 0, 0, 0, 46, 324, 1, 0, 0, 0, 48, 333, 1, 0, 0,
		0, 50, 338, 1, 0, 0, 0, 52, 340, 1, 0, 0, 0, 54, 344, 1, 0, 0, 0, 56, 354,
		1, 0, 0, 0, 58, 360, 1, 0, 0, 0, 60, 367, 1, 0, 0, 0, 62, 411, 1, 0, 0,
		0, 64, 413, 1, 0, 0, 0, 66, 420, 1, 0, 0, 0, 68, 445, 1, 0, 0, 0, 70, 447,
		1, 0, 0, 0, 72, 449, 1, 0, 0, 0, 74, 451, 1, 0, 0, 0, 76, 453, 1, 0, 0,
		0, 78, 460, 1, 0, 0, 0, 80, 467, 1, 0, 0, 0, 82, 474, 1, 0, 0, 0, 84, 480,
		1, 0, 0, 0, 86, 493, 1, 0, 0, 0, 88, 497, 1, 0, 0, 0, 90, 503, 1, 0, 0,
		0, 92, 508, 1, 0, 0, 0, 94, 513, 1, 0, 0, 0, 96, 522, 1, 0, 0, 0, 98, 532,
		1, 0, 0, 0, 100, 535, 1, 0, 0, 0, 102, 557, 1, 0, 0, 0, 104, 559, 1, 0,
		0, 0, 106, 564, 1, 0, 0, 0, 108, 567, 1, 0, 0, 0, 110, 573, 1, 0, 0, 0,
		112, 580, 1, 0, 0, 0, 114, 604, 1, 0, 0, 0, 116, 633, 1, 0, 0, 0, 118,
		642, 1, 0, 0, 0, 120, 644, 1, 0, 0, 0, 122, 661, 1, 0, 0, 0, 124, 667,
		1, 0, 0, 0, 126, 711, 1, 0, 0, 0, 128, 788, 1, 0, 0, 0, 130, 790, 1, 0,
		0, 0, 132, 824, 1, 0, 0, 0, 134, 832, 1, 0, 0, 0, 136, 834, 1, 0, 0, 0,
		138, 846, 1, 0, 0, 0, 140, 848, 1, 0, 0, 0, 142, 862, 1, 0, 0, 0, 144,
		864, 1, 0, 0, 0, 146, 866, 1, 0, 0, 0, 148, 871, 1, 0, 0, 0, 150, 873,
		1, 0, 0, 0, 152, 878, 1, 0, 0, 0, 154, 880, 1, 0, 0, 0, 156, 886, 1, 0,
		0, 0, 158, 160, 5, 1, 0, 0, 159, 158, 1, 0, 0, 0, 159, 160, 1, 0, 0, 0,
		160, 162, 1, 0, 0, 0, 161, 163, 3, 2, 1, 0, 162, 161, 1, 0, 0, 0, 162,
		163, 1, 0, 0, 0, 163, 164, 1, 0, 0, 0, 164, 165, 5, 0, 0, 1, 165, 1, 1,
		0, 0, 0, 166, 168, 3, 4, 2, 0, 167, 166, 1, 0, 0, 0, 168, 169, 1, 0, 0,
		0, 169, 167, 1, 0, 0, 0, 169, 170, 1, 0, 0, 0, 170, 3, 1, 0, 0, 0, 171,
		172, 3, 6, 3, 0, 172, 5, 1, 0, 0, 0, 173, 189, 3, 8, 4, 0, 174, 189, 3,
		44, 22, 0, 175, 189, 3, 12, 6, 0, 176, 189, 3, 32, 16, 0, 177, 189, 3,
		50, 25, 0, 178, 189, 3, 100, 50, 0, 179, 189, 3, 52, 26, 0, 180, 189, 3,
		54, 27, 0, 181, 189, 3, 62, 31, 0, 182, 189, 3, 76, 38, 0, 183, 189, 3,
		78, 39, 0, 184, 189, 3, 80, 40, 0, 185, 189, 3, 82, 41, 0, 186, 189, 3,
		92, 46, 0, 187, 189, 3, 94, 47, 0, 188, 173, 1, 0, 0, 0, 188, 174, 1, 0,
		0, 0, 188, 175, 1, 0, 0, 0, 188, 176, 1, 0, 0, 0, 188, 177, 1, 0, 0, 0,
		188, 178, 1, 0, 0, 0, 188, 179, 1, 0, 0, 0, 188, 180, 1, 0, 0, 0, 188,
		181, 1, 0, 0, 0, 188, 182, 1, 0, 0, 0, 188, 183, 1, 0, 0, 0, 188, 184,
		1, 0, 0, 0, 188, 185, 1, 0, 0, 0, 188, 186, 1, 0, 0, 0, 188, 187, 1, 0,
		0, 0, 189, 7, 1, 0, 0, 0, 190, 192, 5, 9, 0, 0, 191, 193, 3, 10, 5, 0,
		192, 191, 1, 0, 0, 0, 192, 193, 1, 0, 0, 0, 193, 194, 1, 0, 0, 0, 194,
		195, 5, 11, 0, 0, 195, 9, 1, 0, 0, 0, 196, 198, 3, 6, 3, 0, 197, 196, 1,
		0, 0, 0, 198, 199, 1, 0, 0, 0, 199, 197, 1, 0, 0, 0, 199, 200, 1, 0, 0,
		0, 200, 11, 1, 0, 0, 0, 201, 202, 5, 112, 0, 0, 202, 203, 3, 14, 7, 0,
		203, 13, 1, 0, 0, 0, 204, 206, 3, 24, 12, 0, 205, 204, 1, 0, 0, 0, 205,
		206, 1, 0, 0, 0, 206, 207, 1, 0, 0, 0, 207, 208, 3, 26, 13, 0, 208, 209,
		3, 28, 14, 0, 209, 210, 3, 156, 78, 0, 210, 223, 1, 0, 0, 0, 211, 213,
		3, 24, 12, 0, 212, 211, 1, 0, 0, 0, 212, 213, 1, 0, 0, 0, 213, 214, 1,
		0, 0, 0, 214, 215, 3, 16, 8, 0, 215, 216, 3, 28, 14, 0, 216, 217, 3, 156,
		78, 0, 217, 223, 1, 0, 0, 0, 218, 219, 3, 148, 74, 0, 219, 220, 3, 28,
		14, 0, 220, 221, 3, 156, 78, 0, 221, 223, 1, 0, 0, 0, 222, 205, 1, 0, 0,
		0, 222, 212, 1, 0, 0, 0, 222, 218, 1, 0, 0, 0, 223, 15, 1, 0, 0, 0, 224,
		230, 5, 9, 0, 0, 225, 226, 3, 18, 9, 0, 226, 227, 5, 13, 0, 0, 227, 229,
		1, 0, 0, 0, 228, 225, 1, 0, 0, 0, 229, 232, 1, 0, 0, 0, 230, 228, 1, 0,
		0, 0, 230, 231, 1, 0, 0, 0, 231, 237, 1, 0, 0, 0, 232, 230, 1, 0, 0, 0,
		233, 235, 3, 18, 9, 0, 234, 236, 5, 13, 0, 0, 235, 234, 1, 0, 0, 0, 235,
		236, 1, 0, 0, 0, 236, 238, 1, 0, 0, 0, 237, 233, 1, 0, 0, 0, 237, 238,
		1, 0, 0, 0, 238, 239, 1, 0, 0, 0, 239, 240, 5, 11, 0, 0, 240, 17, 1, 0,
		0, 0, 241, 244, 3, 20, 10, 0, 242, 243, 5, 103, 0, 0, 243, 245, 3, 22,
		11, 0, 244, 242, 1, 0, 0, 0, 244, 245, 1, 0, 0, 0, 245, 19, 1, 0, 0, 0,
		246, 249, 3, 148, 74, 0, 247, 249, 5, 125, 0, 0, 248, 246, 1, 0, 0, 0,
		248, 247, 1, 0, 0, 0, 249, 21, 1, 0, 0, 0, 250, 251, 7, 0, 0, 0, 251, 23,
		1, 0, 0, 0, 252, 253, 3, 30, 15, 0, 253, 254, 5, 13, 0, 0, 254, 25, 1,
		0, 0, 0, 255, 256, 5, 26, 0, 0, 256, 257, 5, 103, 0, 0, 257, 258, 3, 148,
		74, 0, 258, 27, 1, 0, 0, 0, 259, 260, 5, 104, 0, 0, 260, 261, 5, 125, 0,
		0, 261, 29, 1, 0, 0, 0, 262, 265, 3, 148, 74, 0, 263, 264, 5, 103, 0, 0,
		264, 266, 3, 148, 74, 0, 265, 263, 1, 0, 0, 0, 265, 266, 1, 0, 0, 0, 266,
		31, 1, 0, 0, 0, 267, 268, 5, 111, 0, 0, 268, 269, 3, 42, 21, 0, 269, 270,
		3, 156, 78, 0, 270, 285, 1, 0, 0, 0, 271, 272, 5, 111, 0, 0, 272, 273,
		3, 38, 19, 0, 273, 274, 3, 156, 78, 0, 274, 285, 1, 0, 0, 0, 275, 276,
		5, 111, 0, 0, 276, 277, 3, 36, 18, 0, 277, 278, 3, 156, 78, 0, 278, 285,
		1, 0, 0, 0, 279, 280, 5, 111, 0, 0, 280, 281, 5, 97, 0, 0, 281, 282, 3,
		126, 63, 0, 282, 283, 3, 156, 78, 0, 283, 285, 1, 0, 0, 0, 284, 267, 1,
		0, 0, 0, 284, 271, 1, 0, 0, 0, 284, 275, 1, 0, 0, 0, 284, 279, 1, 0, 0,
		0, 285, 33, 1, 0, 0, 0, 286, 289, 3, 148, 74, 0, 287, 288, 5, 103, 0, 0,
		288, 290, 3, 148, 74, 0, 289, 287, 1, 0, 0, 0, 289, 290, 1, 0, 0, 0, 290,
		35, 1, 0, 0, 0, 291, 292, 3, 34, 17, 0, 292, 293, 3, 28, 14, 0, 293, 294,
		3, 156, 78, 0, 294, 37, 1, 0, 0, 0, 295, 301, 5, 9, 0, 0, 296, 297, 3,
		40, 20, 0, 297, 298, 5, 13, 0, 0, 298, 300, 1, 0, 0, 0, 299, 296, 1, 0,
		0, 0, 300, 303, 1, 0, 0, 0, 301, 299, 1, 0, 0, 0, 301, 302, 1, 0, 0, 0,
		302, 308, 1, 0, 0, 0, 303, 301, 1, 0, 0, 0, 304, 306, 3, 40, 20, 0, 305,
		307, 5, 13, 0, 0, 306, 305, 1, 0, 0, 0, 306, 307, 1, 0, 0, 0, 307, 309,
		1, 0, 0, 0, 308, 304, 1, 0, 0, 0, 308, 309, 1, 0, 0, 0, 309, 310, 1, 0,
		0, 0, 310, 311, 5, 11, 0, 0, 311, 39, 1, 0, 0, 0, 312, 315, 3, 20, 10,
		0, 313, 314, 5, 103, 0, 0, 314, 316, 3, 20, 10, 0, 315, 313, 1, 0, 0, 0,
		315, 316, 1, 0, 0, 0, 316, 41, 1, 0, 0, 0, 317, 320, 3, 44, 22, 0, 318,
		320, 3, 100, 50, 0, 319, 317, 1, 0, 0, 0, 319, 318, 1, 0, 0, 0, 320, 43,
		1, 0, 0, 0, 321, 322, 3, 46, 23, 0, 322, 323, 3, 156, 78, 0, 323, 45, 1,
		0, 0, 0, 324, 325, 3, 74, 37, 0, 325, 330, 3, 48, 24, 0, 326, 327, 5, 13,
		0, 0, 327, 329, 3, 48, 24, 0, 328, 326, 1, 0, 0, 0, 329, 332, 1, 0, 0,
		0, 330, 328, 1, 0, 0, 0, 330, 331, 1, 0, 0, 0, 331, 47, 1, 0, 0, 0, 332,
		330, 1, 0, 0, 0, 333, 336, 3, 128, 64, 0, 334, 335, 5, 14, 0, 0, 335, 337,
		3, 126, 63, 0, 336, 334, 1, 0, 0, 0, 336, 337, 1, 0, 0, 0, 337, 49, 1,
		0, 0, 0, 338, 339, 5, 12, 0, 0, 339, 51, 1, 0, 0, 0, 340, 341, 4, 26, 0,
		0, 341, 342, 3, 124, 62, 0, 342, 343, 3, 156, 78, 0, 343, 53, 1, 0, 0,
		0, 344, 348, 3, 56, 28, 0, 345, 347, 3, 58, 29, 0, 346, 345, 1, 0, 0, 0,
		347, 350, 1, 0, 0, 0, 348, 346, 1, 0, 0, 0, 348, 349, 1, 0, 0, 0, 349,
		352, 1, 0, 0, 0, 350, 348, 1, 0, 0, 0, 351, 353, 3, 60, 30, 0, 352, 351,
		1, 0, 0, 0, 352, 353, 1, 0, 0, 0, 353, 55, 1, 0, 0, 0, 354, 355, 5, 98,
		0, 0, 355, 356, 5, 7, 0, 0, 356, 357, 3, 124, 62, 0, 357, 358, 5, 8, 0,
		0, 358, 359, 3, 6, 3, 0, 359, 57, 1, 0, 0, 0, 360, 361, 5, 81, 0, 0, 361,
		362, 5, 98, 0, 0, 362, 363, 5, 7, 0, 0, 363, 364, 3, 124, 62, 0, 364, 365,
		5, 8, 0, 0, 365, 366, 3, 6, 3, 0, 366, 59, 1, 0, 0, 0, 367, 368, 5, 81,
		0, 0, 368, 369, 3, 6, 3, 0, 369, 61, 1, 0, 0, 0, 370, 371, 5, 77, 0, 0,
		371, 372, 3, 6, 3, 0, 372, 373, 5, 92, 0, 0, 373, 374, 5, 7, 0, 0, 374,
		375, 3, 124, 62, 0, 375, 376, 5, 8, 0, 0, 376, 377, 3, 156, 78, 0, 377,
		412, 1, 0, 0, 0, 378, 379, 5, 92, 0, 0, 379, 380, 5, 7, 0, 0, 380, 381,
		3, 124, 62, 0, 381, 382, 5, 8, 0, 0, 382, 383, 3, 6, 3, 0, 383, 412, 1,
		0, 0, 0, 384, 385, 5, 90, 0, 0, 385, 387, 5, 7, 0, 0, 386, 388, 3, 68,
		34, 0, 387, 386, 1, 0, 0, 0, 387, 388, 1, 0, 0, 0, 388, 389, 1, 0, 0, 0,
		389, 391, 5, 12, 0, 0, 390, 392, 3, 70, 35, 0, 391, 390, 1, 0, 0, 0, 391,
		392, 1, 0, 0, 0, 392, 393, 1, 0, 0, 0, 393, 395, 5, 12, 0, 0, 394, 396,
		3, 72, 36, 0, 395, 394, 1, 0, 0, 0, 395, 396, 1, 0, 0, 0, 396, 397, 1,
		0, 0, 0, 397, 398, 5, 8, 0, 0, 398, 412, 3, 6, 3, 0, 399, 400, 5, 90, 0,
		0, 400, 401, 5, 7, 0, 0, 401, 404, 3, 74, 37, 0, 402, 405, 3, 150, 75,
		0, 403, 405, 3, 64, 32, 0, 404, 402, 1, 0, 0, 0, 404, 403, 1, 0, 0, 0,
		405, 406, 1, 0, 0, 0, 406, 407, 5, 105, 0, 0, 407, 408, 3, 124, 62, 0,
		408, 409, 5, 8, 0, 0, 409, 410, 3, 6, 3, 0, 410, 412, 1, 0, 0, 0, 411,
		370, 1, 0, 0, 0, 411, 378, 1, 0, 0, 0, 411, 384, 1, 0, 0, 0, 411, 399,
		1, 0, 0, 0, 412, 63, 1, 0, 0, 0, 413, 414, 5, 5, 0, 0, 414, 415, 3, 66,
		33, 0, 415, 416, 5, 6, 0, 0, 416, 65, 1, 0, 0, 0, 417, 419, 5, 13, 0, 0,
		418, 417, 1, 0, 0, 0, 419, 422, 1, 0, 0, 0, 420, 418, 1, 0, 0, 0, 420,
		421, 1, 0, 0, 0, 421, 424, 1, 0, 0, 0, 422, 420, 1, 0, 0, 0, 423, 425,
		3, 150, 75, 0, 424, 423, 1, 0, 0, 0, 424, 425, 1, 0, 0, 0, 425, 434, 1,
		0, 0, 0, 426, 428, 5, 13, 0, 0, 427, 426, 1, 0, 0, 0, 428, 429, 1, 0, 0,
		0, 429, 427, 1, 0, 0, 0, 429, 430, 1, 0, 0, 0, 430, 431, 1, 0, 0, 0, 431,
		433, 3, 150, 75, 0, 432, 427, 1, 0, 0, 0, 433, 436, 1, 0, 0, 0, 434, 432,
		1, 0, 0, 0, 434, 435, 1, 0, 0, 0, 435, 440, 1, 0, 0, 0, 436, 434, 1, 0,
		0, 0, 437, 439, 5, 13, 0, 0, 438, 437, 1, 0, 0, 0, 439, 442, 1, 0, 0, 0,
		440, 438, 1, 0, 0, 0, 440, 441, 1, 0, 0, 0, 441, 67, 1, 0, 0, 0, 442, 440,
		1, 0, 0, 0, 443, 446, 3, 124, 62, 0, 444, 446, 3, 46, 23, 0, 445, 443,
		1, 0, 0, 0, 445, 444, 1, 0, 0, 0, 446, 69, 1, 0, 0, 0, 447, 448, 3, 124,
		62, 0, 448, 71, 1, 0, 0, 0, 449, 450, 3, 124, 62, 0, 450, 73, 1, 0, 0,
		0, 451, 452, 7, 1, 0, 0, 452, 75, 1, 0, 0, 0, 453, 456, 5, 89, 0, 0, 454,
		455, 4, 38, 1, 0, 455, 457, 3, 150, 75, 0, 456, 454, 1, 0, 0, 0, 456, 457,
		1, 0, 0, 0, 457, 458, 1, 0, 0, 0, 458, 459, 3, 156, 78, 0, 459, 77, 1,
		0, 0, 0, 460, 463, 5, 76, 0, 0, 461, 462, 4, 39, 2, 0, 462, 464, 3, 150,
		75, 0, 463, 461, 1, 0, 0, 0, 463, 464, 1, 0, 0, 0, 464, 465, 1, 0, 0, 0,
		465, 466, 3, 156, 78, 0, 466, 79, 1, 0, 0, 0, 467, 470, 5, 87, 0, 0, 468,
		469, 4, 40, 3, 0, 469, 471, 3, 124, 62, 0, 470, 468, 1, 0, 0, 0, 470, 471,
		1, 0, 0, 0, 471, 472, 1, 0, 0, 0, 472, 473, 3, 156, 78, 0, 473, 81, 1,
		0, 0, 0, 474, 475, 5, 91, 0, 0, 475, 476, 5, 7, 0, 0, 476, 477, 3, 124,
		62, 0, 477, 478, 5, 8, 0, 0, 478, 479, 3, 84, 42, 0, 479, 83, 1, 0, 0,
		0, 480, 482, 5, 9, 0, 0, 481, 483, 3, 86, 43, 0, 482, 481, 1, 0, 0, 0,
		482, 483, 1, 0, 0, 0, 483, 488, 1, 0, 0, 0, 484, 486, 3, 90, 45, 0, 485,
		487, 3, 86, 43, 0, 486, 485, 1, 0, 0, 0, 486, 487, 1, 0, 0, 0, 487, 489,
		1, 0, 0, 0, 488, 484, 1, 0, 0, 0, 488, 489, 1, 0, 0, 0, 489, 490, 1, 0,
		0, 0, 490, 491, 5, 11, 0, 0, 491, 85, 1, 0, 0, 0, 492, 494, 3, 88, 44,
		0, 493, 492, 1, 0, 0, 0, 494, 495, 1, 0, 0, 0, 495, 493, 1, 0, 0, 0, 495,
		496, 1, 0, 0, 0, 496, 87, 1, 0, 0, 0, 497, 498, 5, 80, 0, 0, 498, 499,
		3, 124, 62, 0, 499, 501, 5, 17, 0, 0, 500, 502, 3, 10, 5, 0, 501, 500,
		1, 0, 0, 0, 501, 502, 1, 0, 0, 0, 502, 89, 1, 0, 0, 0, 503, 504, 5, 97,
		0, 0, 504, 506, 5, 17, 0, 0, 505, 507, 3, 10, 5, 0, 506, 505, 1, 0, 0,
		0, 506, 507, 1, 0, 0, 0, 507, 91, 1, 0, 0, 0, 508, 509, 5, 99, 0, 0, 509,
		510, 4, 46, 4, 0, 510, 511, 3, 124, 62, 0, 511, 512, 3, 156, 78, 0, 512,
		93, 1, 0, 0, 0, 513, 514, 5, 102, 0, 0, 514, 520, 3, 8, 4, 0, 515, 517,
		3, 96, 48, 0, 516, 518, 3, 98, 49, 0, 517, 516, 1, 0, 0, 0, 517, 518, 1,
		0, 0, 0, 518, 521, 1, 0, 0, 0, 519, 521, 3, 98, 49, 0, 520, 515, 1, 0,
		0, 0, 520, 519, 1, 0, 0, 0, 521, 95, 1, 0, 0, 0, 522, 528, 5, 85, 0, 0,
		523, 525, 5, 7, 0, 0, 524, 526, 3, 128, 64, 0, 525, 524, 1, 0, 0, 0, 525,
		526, 1, 0, 0, 0, 526, 527, 1, 0, 0, 0, 527, 529, 5, 8, 0, 0, 528, 523,
		1, 0, 0, 0, 528, 529, 1, 0, 0, 0, 529, 530, 1, 0, 0, 0, 530, 531, 3, 8,
		4, 0, 531, 97, 1, 0, 0, 0, 532, 533, 5, 86, 0, 0, 533, 534, 3, 8, 4, 0,
		534, 99, 1, 0, 0, 0, 535, 536, 5, 94, 0, 0, 536, 537, 3, 150, 75, 0, 537,
		539, 5, 7, 0, 0, 538, 540, 3, 102, 51, 0, 539, 538, 1, 0, 0, 0, 539, 540,
		1, 0, 0, 0, 540, 541, 1, 0, 0, 0, 541, 542, 5, 8, 0, 0, 542, 543, 3, 108,
		54, 0, 543, 101, 1, 0, 0, 0, 544, 549, 3, 104, 52, 0, 545, 546, 5, 13,
		0, 0, 546, 548, 3, 104, 52, 0, 547, 545, 1, 0, 0, 0, 548, 551, 1, 0, 0,
		0, 549, 547, 1, 0, 0, 0, 549, 550, 1, 0, 0, 0, 550, 554, 1, 0, 0, 0, 551,
		549, 1, 0, 0, 0, 552, 553, 5, 13, 0, 0, 553, 555, 3, 106, 53, 0, 554, 552,
		1, 0, 0, 0, 554, 555, 1, 0, 0, 0, 555, 558, 1, 0, 0, 0, 556, 558, 3, 106,
		53, 0, 557, 544, 1, 0, 0, 0, 557, 556, 1, 0, 0, 0, 558, 103, 1, 0, 0, 0,
		559, 562, 3, 128, 64, 0, 560, 561, 5, 14, 0, 0, 561, 563, 3, 126, 63, 0,
		562, 560, 1, 0, 0, 0, 562, 563, 1, 0, 0, 0, 563, 105, 1, 0, 0, 0, 564,
		565, 5, 18, 0, 0, 565, 566, 3, 126, 63, 0, 566, 107, 1, 0, 0, 0, 567, 569,
		5, 9, 0, 0, 568, 570, 3, 2, 1, 0, 569, 568, 1, 0, 0, 0, 569, 570, 1, 0,
		0, 0, 570, 571, 1, 0, 0, 0, 571, 572, 5, 11, 0, 0, 572, 109, 1, 0, 0, 0,
		573, 574, 5, 5, 0, 0, 574, 575, 3, 112, 56, 0, 575, 576, 5, 6, 0, 0, 576,
		111, 1, 0, 0, 0, 577, 579, 5, 13, 0, 0, 578, 577, 1, 0, 0, 0, 579, 582,
		1, 0, 0, 0, 580, 578, 1, 0, 0, 0, 580, 581, 1, 0, 0, 0, 581, 584, 1, 0,
		0, 0, 582, 580, 1, 0, 0, 0, 583, 585, 3, 114, 57, 0, 584, 583, 1, 0, 0,
		0, 584, 585, 1, 0, 0, 0, 585, 594, 1, 0, 0, 0, 586, 588, 5, 13, 0, 0, 587,
		586, 1, 0, 0, 0, 588, 589, 1, 0, 0, 0, 589, 587, 1, 0, 0, 0, 589, 590,
		1, 0, 0, 0, 590, 591, 1, 0, 0, 0, 591, 593, 3, 114, 57, 0, 592, 587, 1,
		0, 0, 0, 593, 596, 1, 0, 0, 0, 594, 592, 1, 0, 0, 0, 594, 595, 1, 0, 0,
		0, 595, 600, 1, 0, 0, 0, 596, 594, 1, 0, 0, 0, 597, 599, 5, 13, 0, 0, 598,
		597, 1, 0, 0, 0, 599, 602, 1, 0, 0, 0, 600, 598, 1, 0, 0, 0, 600, 601,
		1, 0, 0, 0, 601, 113, 1, 0, 0, 0, 602, 600, 1, 0, 0, 0, 603, 605, 5, 18,
		0, 0, 604, 603, 1, 0, 0, 0, 604, 605, 1, 0, 0, 0, 605, 606, 1, 0, 0, 0,
		606, 607, 3, 126, 63, 0, 607, 115, 1, 0, 0, 0, 608, 609, 3, 118, 59, 0,
		609, 610, 5, 17, 0, 0, 610, 611, 3, 126, 63, 0, 611, 634, 1, 0, 0, 0, 612,
		613, 5, 5, 0, 0, 613, 614, 3, 126, 63, 0, 614, 615, 5, 6, 0, 0, 615, 616,
		5, 17, 0, 0, 616, 617, 3, 126, 63, 0, 617, 634, 1, 0, 0, 0, 618, 620, 5,
		26, 0, 0, 619, 618, 1, 0, 0, 0, 619, 620, 1, 0, 0, 0, 620, 621, 1, 0, 0,
		0, 621, 622, 3, 118, 59, 0, 622, 624, 5, 7, 0, 0, 623, 625, 3, 102, 51,
		0, 624, 623, 1, 0, 0, 0, 624, 625, 1, 0, 0, 0, 625, 626, 1, 0, 0, 0, 626,
		627, 5, 8, 0, 0, 627, 628, 3, 108, 54, 0, 628, 634, 1, 0, 0, 0, 629, 631,
		5, 18, 0, 0, 630, 629, 1, 0, 0, 0, 630, 631, 1, 0, 0, 0, 631, 632, 1, 0,
		0, 0, 632, 634, 3, 126, 63, 0, 633, 608, 1, 0, 0, 0, 633, 612, 1, 0, 0,
		0, 633, 619, 1, 0, 0, 0, 633, 630, 1, 0, 0, 0, 634, 117, 1, 0, 0, 0, 635,
		643, 3, 148, 74, 0, 636, 643, 5, 125, 0, 0, 637, 643, 3, 144, 72, 0, 638,
		639, 5, 5, 0, 0, 639, 640, 3, 126, 63, 0, 640, 641, 5, 6, 0, 0, 641, 643,
		1, 0, 0, 0, 642, 635, 1, 0, 0, 0, 642, 636, 1, 0, 0, 0, 642, 637, 1, 0,
		0, 0, 642, 638, 1, 0, 0, 0, 643, 119, 1, 0, 0, 0, 644, 656, 5, 7, 0, 0,
		645, 650, 3, 122, 61, 0, 646, 647, 5, 13, 0, 0, 647, 649, 3, 122, 61, 0,
		648, 646, 1, 0, 0, 0, 649, 652, 1, 0, 0, 0, 650, 648, 1, 0, 0, 0, 650,
		651, 1, 0, 0, 0, 651, 654, 1, 0, 0, 0, 652, 650, 1, 0, 0, 0, 653, 655,
		5, 13, 0, 0, 654, 653, 1, 0, 0, 0, 654, 655, 1, 0, 0, 0, 655, 657, 1, 0,
		0, 0, 656, 645, 1, 0, 0, 0, 656, 657, 1, 0, 0, 0, 657, 658, 1, 0, 0, 0,
		658, 659, 5, 8, 0, 0, 659, 121, 1, 0, 0, 0, 660, 662, 5, 18, 0, 0, 661,
		660, 1, 0, 0, 0, 661, 662, 1, 0, 0, 0, 662, 665, 1, 0, 0, 0, 663, 666,
		3, 126, 63, 0, 664, 666, 3, 150, 75, 0, 665, 663, 1, 0, 0, 0, 665, 664,
		1, 0, 0, 0, 666, 123, 1, 0, 0, 0, 667, 672, 3, 126, 63, 0, 668, 669, 5,
		13, 0, 0, 669, 671, 3, 126, 63, 0, 670, 668, 1, 0, 0, 0, 671, 674, 1, 0,
		0, 0, 672, 670, 1, 0, 0, 0, 672, 673, 1, 0, 0, 0, 673, 125, 1, 0, 0, 0,
		674, 672, 1, 0, 0, 0, 675, 676, 6, 63, -1, 0, 676, 712, 3, 132, 66, 0,
		677, 678, 7, 2, 0, 0, 678, 680, 3, 126, 63, 0, 679, 681, 5, 16, 0, 0, 680,
		679, 1, 0, 0, 0, 680, 681, 1, 0, 0, 0, 681, 682, 1, 0, 0, 0, 682, 683,
		3, 120, 60, 0, 683, 712, 1, 0, 0, 0, 684, 685, 5, 82, 0, 0, 685, 686, 3,
		150, 75, 0, 686, 687, 3, 120, 60, 0, 687, 712, 1, 0, 0, 0, 688, 689, 5,
		100, 0, 0, 689, 712, 3, 126, 63, 27, 690, 691, 5, 20, 0, 0, 691, 712, 3,
		126, 63, 26, 692, 693, 5, 21, 0, 0, 693, 712, 3, 126, 63, 25, 694, 695,
		5, 22, 0, 0, 695, 712, 3, 126, 63, 24, 696, 697, 5, 23, 0, 0, 697, 712,
		3, 126, 63, 23, 698, 699, 5, 24, 0, 0, 699, 712, 3, 126, 63, 22, 700, 701,
		5, 25, 0, 0, 701, 712, 3, 126, 63, 21, 702, 712, 5, 95, 0, 0, 703, 712,
		3, 150, 75, 0, 704, 712, 3, 138, 69, 0, 705, 712, 3, 110, 55, 0, 706, 712,
		3, 130, 65, 0, 707, 708, 5, 7, 0, 0, 708, 709, 3, 124, 62, 0, 709, 710,
		5, 8, 0, 0, 710, 712, 1, 0, 0, 0, 711, 675, 1, 0, 0, 0, 711, 677, 1, 0,
		0, 0, 711, 684, 1, 0, 0, 0, 711, 688, 1, 0, 0, 0, 711, 690, 1, 0, 0, 0,
		711, 692, 1, 0, 0, 0, 711, 694, 1, 0, 0, 0, 711, 696, 1, 0, 0, 0, 711,
		698, 1, 0, 0, 0, 711, 700, 1, 0, 0, 0, 711, 702, 1, 0, 0, 0, 711, 703,
		1, 0, 0, 0, 711, 704, 1, 0, 0, 0, 711, 705, 1, 0, 0, 0, 711, 706, 1, 0,
		0, 0, 711, 707, 1, 0, 0, 0, 712, 782, 1, 0, 0, 0, 713, 714, 10, 20, 0,
		0, 714, 715, 5, 29, 0, 0, 715, 781, 3, 126, 63, 20, 716, 717, 10, 19, 0,
		0, 717, 718, 7, 3, 0, 0, 718, 781, 3, 126, 63, 20, 719, 720, 10, 18, 0,
		0, 720, 721, 7, 4, 0, 0, 721, 781, 3, 126, 63, 19, 722, 723, 10, 17, 0,
		0, 723, 724, 5, 30, 0, 0, 724, 781, 3, 126, 63, 18, 725, 726, 10, 16, 0,
		0, 726, 727, 7, 5, 0, 0, 727, 781, 3, 126, 63, 17, 728, 729, 10, 15, 0,
		0, 729, 730, 7, 6, 0, 0, 730, 781, 3, 126, 63, 16, 731, 732, 10, 14, 0,
		0, 732, 733, 5, 101, 0, 0, 733, 781, 3, 126, 63, 15, 734, 735, 10, 13,
		0, 0, 735, 736, 7, 7, 0, 0, 736, 781, 3, 126, 63, 14, 737, 738, 10, 12,
		0, 0, 738, 739, 7, 8, 0, 0, 739, 781, 3, 126, 63, 13, 740, 741, 10, 11,
		0, 0, 741, 742, 7, 9, 0, 0, 742, 781, 3, 126, 63, 12, 743, 744, 10, 10,
		0, 0, 744, 745, 5, 15, 0, 0, 745, 746, 3, 126, 63, 0, 746, 747, 5, 17,
		0, 0, 747, 748, 3, 126, 63, 11, 748, 781, 1, 0, 0, 0, 749, 750, 10, 9,
		0, 0, 750, 751, 5, 14, 0, 0, 751, 781, 3, 126, 63, 9, 752, 753, 10, 8,
		0, 0, 753, 754, 3, 136, 68, 0, 754, 755, 3, 126, 63, 8, 755, 781, 1, 0,
		0, 0, 756, 758, 10, 34, 0, 0, 757, 759, 5, 16, 0, 0, 758, 757, 1, 0, 0,
		0, 758, 759, 1, 0, 0, 0, 759, 760, 1, 0, 0, 0, 760, 761, 5, 5, 0, 0, 761,
		762, 3, 124, 62, 0, 762, 763, 5, 6, 0, 0, 763, 781, 1, 0, 0, 0, 764, 765,
		10, 33, 0, 0, 765, 766, 7, 10, 0, 0, 766, 781, 3, 148, 74, 0, 767, 769,
		10, 32, 0, 0, 768, 770, 5, 16, 0, 0, 769, 768, 1, 0, 0, 0, 769, 770, 1,
		0, 0, 0, 770, 771, 1, 0, 0, 0, 771, 781, 3, 120, 60, 0, 772, 773, 10, 29,
		0, 0, 773, 774, 4, 63, 22, 0, 774, 781, 5, 20, 0, 0, 775, 776, 10, 28,
		0, 0, 776, 777, 4, 63, 24, 0, 777, 781, 5, 21, 0, 0, 778, 779, 10, 7, 0,
		0, 779, 781, 3, 140, 70, 0, 780, 713, 1, 0, 0, 0, 780, 716, 1, 0, 0, 0,
		780, 719, 1, 0, 0, 0, 780, 722, 1, 0, 0, 0, 780, 725, 1, 0, 0, 0, 780,
		728, 1, 0, 0, 0, 780, 731, 1, 0, 0, 0, 780, 734, 1, 0, 0, 0, 780, 737,
		1, 0, 0, 0, 780, 740, 1, 0, 0, 0, 780, 743, 1, 0, 0, 0, 780, 749, 1, 0,
		0, 0, 780, 752, 1, 0, 0, 0, 780, 756, 1, 0, 0, 0, 780, 764, 1, 0, 0, 0,
		780, 767, 1, 0, 0, 0, 780, 772, 1, 0, 0, 0, 780, 775, 1, 0, 0, 0, 780,
		778, 1, 0, 0, 0, 781, 784, 1, 0, 0, 0, 782, 780, 1, 0, 0, 0, 782, 783,
		1, 0, 0, 0, 783, 127, 1, 0, 0, 0, 784, 782, 1, 0, 0, 0, 785, 789, 3, 150,
		75, 0, 786, 789, 3, 110, 55, 0, 787, 789, 3, 130, 65, 0, 788, 785, 1, 0,
		0, 0, 788, 786, 1, 0, 0, 0, 788, 787, 1, 0, 0, 0, 789, 129, 1, 0, 0, 0,
		790, 802, 5, 9, 0, 0, 791, 796, 3, 116, 58, 0, 792, 793, 5, 13, 0, 0, 793,
		795, 3, 116, 58, 0, 794, 792, 1, 0, 0, 0, 795, 798, 1, 0, 0, 0, 796, 794,
		1, 0, 0, 0, 796, 797, 1, 0, 0, 0, 797, 800, 1, 0, 0, 0, 798, 796, 1, 0,
		0, 0, 799, 801, 5, 13, 0, 0, 800, 799, 1, 0, 0, 0, 800, 801, 1, 0, 0, 0,
		801, 803, 1, 0, 0, 0, 802, 791, 1, 0, 0, 0, 802, 803, 1, 0, 0, 0, 803,
		804, 1, 0, 0, 0, 804, 805, 5, 11, 0, 0, 805, 131, 1, 0, 0, 0, 806, 808,
		5, 94, 0, 0, 807, 809, 5, 26, 0, 0, 808, 807, 1, 0, 0, 0, 808, 809, 1,
		0, 0, 0, 809, 810, 1, 0, 0, 0, 810, 812, 5, 7, 0, 0, 811, 813, 3, 102,
		51, 0, 812, 811, 1, 0, 0, 0, 812, 813, 1, 0, 0, 0, 813, 814, 1, 0, 0, 0,
		814, 815, 5, 8, 0, 0, 815, 825, 3, 108, 54, 0, 816, 817, 3, 134, 67, 0,
		817, 818, 5, 61, 0, 0, 818, 819, 3, 108, 54, 0, 819, 825, 1, 0, 0, 0, 820,
		821, 3, 134, 67, 0, 821, 822, 5, 61, 0, 0, 822, 823, 3, 126, 63, 0, 823,
		825, 1, 0, 0, 0, 824, 806, 1, 0, 0, 0, 824, 816, 1, 0, 0, 0, 824, 820,
		1, 0, 0, 0, 825, 133, 1, 0, 0, 0, 826, 833, 3, 150, 75, 0, 827, 829, 5,
		7, 0, 0, 828, 830, 3, 102, 51, 0, 829, 828, 1, 0, 0, 0, 829, 830, 1, 0,
		0, 0, 830, 831, 1, 0, 0, 0, 831, 833, 5, 8, 0, 0, 832, 826, 1, 0, 0, 0,
		832, 827, 1, 0, 0, 0, 833, 135, 1, 0, 0, 0, 834, 835, 7, 11, 0, 0, 835,
		137, 1, 0, 0, 0, 836, 847, 5, 62, 0, 0, 837, 847, 5, 65, 0, 0, 838, 847,
		5, 125, 0, 0, 839, 847, 5, 64, 0, 0, 840, 847, 5, 63, 0, 0, 841, 847, 5,
		66, 0, 0, 842, 847, 3, 140, 70, 0, 843, 847, 3, 146, 73, 0, 844, 847, 5,
		4, 0, 0, 845, 847, 3, 144, 72, 0, 846, 836, 1, 0, 0, 0, 846, 837, 1, 0,
		0, 0, 846, 838, 1, 0, 0, 0, 846, 839, 1, 0, 0, 0, 846, 840, 1, 0, 0, 0,
		846, 841, 1, 0, 0, 0, 846, 842, 1, 0, 0, 0, 846, 843, 1, 0, 0, 0, 846,
		844, 1, 0, 0, 0, 846, 845, 1, 0, 0, 0, 847, 139, 1, 0, 0, 0, 848, 852,
		5, 126, 0, 0, 849, 851, 3, 142, 71, 0, 850, 849, 1, 0, 0, 0, 851, 854,
		1, 0, 0, 0, 852, 850, 1, 0, 0, 0, 852, 853, 1, 0, 0, 0, 853, 855, 1, 0,
		0, 0, 854, 852, 1, 0, 0, 0, 855, 856, 5, 126, 0, 0, 856, 141, 1, 0, 0,
		0, 857, 863, 5, 133, 0, 0, 858, 859, 5, 132, 0, 0, 859, 860, 3, 126, 63,
		0, 860, 861, 5, 10, 0, 0, 861, 863, 1, 0, 0, 0, 862, 857, 1, 0, 0, 0, 862,
		858, 1, 0, 0, 0, 863, 143, 1, 0, 0, 0, 864, 865, 7, 12, 0, 0, 865, 145,
		1, 0, 0, 0, 866, 867, 7, 13, 0, 0, 867, 147, 1, 0, 0, 0, 868, 872, 3, 150,
		75, 0, 869, 872, 3, 152, 76, 0, 870, 872, 5, 63, 0, 0, 871, 868, 1, 0,
		0, 0, 871, 869, 1, 0, 0, 0, 871, 870, 1, 0, 0, 0, 872, 149, 1, 0, 0, 0,
		873, 874, 7, 14, 0, 0, 874, 151, 1, 0, 0, 0, 875, 879, 3, 154, 77, 0, 876,
		879, 5, 62, 0, 0, 877, 879, 5, 65, 0, 0, 878, 875, 1, 0, 0, 0, 878, 876,
		1, 0, 0, 0, 878, 877, 1, 0, 0, 0, 879, 153, 1, 0, 0, 0, 880, 881, 7, 15,
		0, 0, 881, 155, 1, 0, 0, 0, 882, 887, 5, 12, 0, 0, 883, 887, 5, 0, 0, 1,
		884, 887, 4, 78, 26, 0, 885, 887, 4, 78, 27, 0, 886, 882, 1, 0, 0, 0, 886,
		883, 1, 0, 0, 0, 886, 884, 1, 0, 0, 0, 886, 885, 1, 0, 0, 0, 887, 157,
		1, 0, 0, 0, 94, 159, 162, 169, 188, 192, 199, 205, 212, 222, 230, 235,
		237, 244, 248, 265, 284, 289, 301, 306, 308, 315, 319, 330, 336, 348, 352,
		387, 391, 395, 404, 411, 420, 424, 429, 434, 440, 445, 456, 463, 470, 482,
		486, 488, 495, 501, 506, 517, 520, 525, 528, 539, 549, 554, 557, 562, 569,
		580, 584, 589, 594, 600, 604, 619, 624, 630, 633, 642, 650, 654, 656, 661,
		665, 672, 680, 711, 758, 769, 780, 782, 788, 796, 800, 802, 808, 812, 824,
		829, 832, 846, 852, 862, 871, 878, 886,
	}
	deserializer := antlr.NewATNDeserializer(nil)
	staticData.atn = deserializer.Deserialize(staticData.serializedATN)
	atn := staticData.atn
	staticData.decisionToDFA = make([]*antlr.DFA, len(atn.DecisionToState))
	decisionToDFA := staticData.decisionToDFA
	for index, state := range atn.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(state, index)
	}
}

// ServerScriptParserInit initializes any static state used to implement ServerScriptParser. By default the
// static state used to implement the parser is lazily initialized during the first call to
// NewServerScriptParser(). You can call this function if you wish to initialize the static state ahead
// of time.
func ServerScriptParserInit() {
	staticData := &ServerScriptParserParserStaticData
	staticData.once.Do(serverscriptparserParserInit)
}

// NewServerScriptParser produces a new parser instance for the optional input antlr.TokenStream.
func NewServerScriptParser(input antlr.TokenStream) *ServerScriptParser {
	ServerScriptParserInit()
	this := new(ServerScriptParser)
	this.BaseParser = antlr.NewBaseParser(input)
	staticData := &ServerScriptParserParserStaticData
	this.Interpreter = antlr.NewParserATNSimulator(this, staticData.atn, staticData.decisionToDFA, staticData.PredictionContextCache)
	this.RuleNames = staticData.RuleNames
	this.LiteralNames = staticData.LiteralNames
	this.SymbolicNames = staticData.SymbolicNames
	this.GrammarFileName = "ServerScriptParser.g4"

	return this
}

// ServerScriptParser tokens.
const (
	ServerScriptParserEOF                           = antlr.TokenEOF
	ServerScriptParserHashBangLine                  = 1
	ServerScriptParserMultiLineComment              = 2
	ServerScriptParserSingleLineComment             = 3
	ServerScriptParserRegularExpressionLiteral      = 4
	ServerScriptParserOpenBracket                   = 5
	ServerScriptParserCloseBracket                  = 6
	ServerScriptParserOpenParen                     = 7
	ServerScriptParserCloseParen                    = 8
	ServerScriptParserOpenBrace                     = 9
	ServerScriptParserTemplateCloseBrace            = 10
	ServerScriptParserCloseBrace                    = 11
	ServerScriptParserSemiColon                     = 12
	ServerScriptParserComma                         = 13
	ServerScriptParserAssign                        = 14
	ServerScriptParserQuestionMark                  = 15
	ServerScriptParserQuestionMarkDot               = 16
	ServerScriptParserColon                         = 17
	ServerScriptParserEllipsis                      = 18
	ServerScriptParserDot                           = 19
	ServerScriptParserPlusPlus                      = 20
	ServerScriptParserMinusMinus                    = 21
	ServerScriptParserPlus                          = 22
	ServerScriptParserMinus                         = 23
	ServerScriptParserBitNot                        = 24
	ServerScriptParserNot                           = 25
	ServerScriptParserMultiply                      = 26
	ServerScriptParserDivide                        = 27
	ServerScriptParserModulus                       = 28
	ServerScriptParserPower                         = 29
	ServerScriptParserNullCoalesce                  = 30
	ServerScriptParserHashtag                       = 31
	ServerScriptParserRightShiftArithmetic          = 32
	ServerScriptParserLeftShiftArithmetic           = 33
	ServerScriptParserRightShiftLogical             = 34
	ServerScriptParserLessThan                      = 35
	ServerScriptParserMoreThan                      = 36
	ServerScriptParserLessThanEquals                = 37
	ServerScriptParserGreaterThanEquals             = 38
	ServerScriptParserEquals_                       = 39
	ServerScriptParserNotEquals                     = 40
	ServerScriptParserIdentityEquals                = 41
	ServerScriptParserIdentityNotEquals             = 42
	ServerScriptParserBitAnd                        = 43
	ServerScriptParserBitXOr                        = 44
	ServerScriptParserBitOr                         = 45
	ServerScriptParserAnd                           = 46
	ServerScriptParserOr                            = 47
	ServerScriptParserMultiplyAssign                = 48
	ServerScriptParserDivideAssign                  = 49
	ServerScriptParserModulusAssign                 = 50
	ServerScriptParserPlusAssign                    = 51
	ServerScriptParserMinusAssign                   = 52
	ServerScriptParserLeftShiftArithmeticAssign     = 53
	ServerScriptParserRightShiftArithmeticAssign    = 54
	ServerScriptParserRightShiftLogicalAssign       = 55
	ServerScriptParserBitAndAssign                  = 56
	ServerScriptParserBitXorAssign                  = 57
	ServerScriptParserBitOrAssign                   = 58
	ServerScriptParserPowerAssign                   = 59
	ServerScriptParserNullishCoalescingAssign       = 60
	ServerScriptParserARROW                         = 61
	ServerScriptParserNullLiteral                   = 62
	ServerScriptParserNaNLiteral                    = 63
	ServerScriptParserUndefinedLiteral              = 64
	ServerScriptParserBooleanLiteral                = 65
	ServerScriptParserInfinityLiteral               = 66
	ServerScriptParserDecimalLiteral                = 67
	ServerScriptParserExponentLiteral               = 68
	ServerScriptParserHexIntegerLiteral             = 69
	ServerScriptParserOctalIntegerLiteral           = 70
	ServerScriptParserBinaryIntegerLiteral          = 71
	ServerScriptParserBigHexIntegerLiteral          = 72
	ServerScriptParserBigOctalIntegerLiteral        = 73
	ServerScriptParserBigBinaryIntegerLiteral       = 74
	ServerScriptParserBigDecimalIntegerLiteral      = 75
	ServerScriptParserBreak                         = 76
	ServerScriptParserDo                            = 77
	ServerScriptParserInstanceof                    = 78
	ServerScriptParserTypeof                        = 79
	ServerScriptParserCase                          = 80
	ServerScriptParserElse                          = 81
	ServerScriptParserNew                           = 82
	ServerScriptParserVar                           = 83
	ServerScriptParserLet                           = 84
	ServerScriptParserCatch                         = 85
	ServerScriptParserFinally                       = 86
	ServerScriptParserReturn                        = 87
	ServerScriptParserVoid                          = 88
	ServerScriptParserContinue                      = 89
	ServerScriptParserFor                           = 90
	ServerScriptParserSwitch                        = 91
	ServerScriptParserWhile                         = 92
	ServerScriptParserDebugger                      = 93
	ServerScriptParserFunction_                     = 94
	ServerScriptParserThis                          = 95
	ServerScriptParserWith                          = 96
	ServerScriptParserDefault                       = 97
	ServerScriptParserIf                            = 98
	ServerScriptParserThrow                         = 99
	ServerScriptParserDelete                        = 100
	ServerScriptParserIn                            = 101
	ServerScriptParserTry                           = 102
	ServerScriptParserAs                            = 103
	ServerScriptParserFrom                          = 104
	ServerScriptParserOf                            = 105
	ServerScriptParserClass                         = 106
	ServerScriptParserEnum                          = 107
	ServerScriptParserExtends                       = 108
	ServerScriptParserSuper                         = 109
	ServerScriptParserConst                         = 110
	ServerScriptParserExport                        = 111
	ServerScriptParserImport                        = 112
	ServerScriptParserAsync                         = 113
	ServerScriptParserSync                          = 114
	ServerScriptParserAwait                         = 115
	ServerScriptParserYield                         = 116
	ServerScriptParserImplements                    = 117
	ServerScriptParserPrivate                       = 118
	ServerScriptParserPublic                        = 119
	ServerScriptParserInterface                     = 120
	ServerScriptParserPackage                       = 121
	ServerScriptParserProtected                     = 122
	ServerScriptParserStatic                        = 123
	ServerScriptParserIdentifier                    = 124
	ServerScriptParserStringLiteral                 = 125
	ServerScriptParserBackTick                      = 126
	ServerScriptParserWhiteSpaces                   = 127
	ServerScriptParserLineTerminator                = 128
	ServerScriptParserHtmlComment                   = 129
	ServerScriptParserCDataComment                  = 130
	ServerScriptParserUnexpectedCharacter           = 131
	ServerScriptParserTemplateStringStartExpression = 132
	ServerScriptParserTemplateStringAtom            = 133
)

// ServerScriptParser rules.
const (
	ServerScriptParserRULE_program                 = 0
	ServerScriptParserRULE_sourceElements          = 1
	ServerScriptParserRULE_sourceElement           = 2
	ServerScriptParserRULE_statement               = 3
	ServerScriptParserRULE_block                   = 4
	ServerScriptParserRULE_statementList           = 5
	ServerScriptParserRULE_importStatement         = 6
	ServerScriptParserRULE_importFromBlock         = 7
	ServerScriptParserRULE_importModuleItems       = 8
	ServerScriptParserRULE_importAliasName         = 9
	ServerScriptParserRULE_moduleExportName        = 10
	ServerScriptParserRULE_importedBinding         = 11
	ServerScriptParserRULE_importDefault           = 12
	ServerScriptParserRULE_importNamespace         = 13
	ServerScriptParserRULE_importFrom              = 14
	ServerScriptParserRULE_aliasName               = 15
	ServerScriptParserRULE_exportStatement         = 16
	ServerScriptParserRULE_exportNamespace         = 17
	ServerScriptParserRULE_exportFromBlock         = 18
	ServerScriptParserRULE_exportModuleItems       = 19
	ServerScriptParserRULE_exportAliasName         = 20
	ServerScriptParserRULE_declaration             = 21
	ServerScriptParserRULE_variableStatement       = 22
	ServerScriptParserRULE_variableDeclarationList = 23
	ServerScriptParserRULE_variableDeclaration     = 24
	ServerScriptParserRULE_emptyStatement_         = 25
	ServerScriptParserRULE_expressionStatement     = 26
	ServerScriptParserRULE_ifStatement             = 27
	ServerScriptParserRULE_ifBlock                 = 28
	ServerScriptParserRULE_elseIfBlock             = 29
	ServerScriptParserRULE_elseBlock               = 30
	ServerScriptParserRULE_iterationStatement      = 31
	ServerScriptParserRULE_ofArrayLiteral          = 32
	ServerScriptParserRULE_identifierList          = 33
	ServerScriptParserRULE_forStatement1           = 34
	ServerScriptParserRULE_forStatement2           = 35
	ServerScriptParserRULE_forStatement3           = 36
	ServerScriptParserRULE_varModifier             = 37
	ServerScriptParserRULE_continueStatement       = 38
	ServerScriptParserRULE_breakStatement          = 39
	ServerScriptParserRULE_returnStatement         = 40
	ServerScriptParserRULE_switchStatement         = 41
	ServerScriptParserRULE_caseBlock               = 42
	ServerScriptParserRULE_caseClauses             = 43
	ServerScriptParserRULE_caseClause              = 44
	ServerScriptParserRULE_defaultClause           = 45
	ServerScriptParserRULE_throwStatement          = 46
	ServerScriptParserRULE_tryStatement            = 47
	ServerScriptParserRULE_catchProduction         = 48
	ServerScriptParserRULE_finallyProduction       = 49
	ServerScriptParserRULE_functionDeclaration     = 50
	ServerScriptParserRULE_formalParameterList     = 51
	ServerScriptParserRULE_formalParameterArg      = 52
	ServerScriptParserRULE_lastFormalParameterArg  = 53
	ServerScriptParserRULE_functionBody            = 54
	ServerScriptParserRULE_arrayLiteral            = 55
	ServerScriptParserRULE_elementList             = 56
	ServerScriptParserRULE_arrayElement            = 57
	ServerScriptParserRULE_propertyAssignment      = 58
	ServerScriptParserRULE_propertyName            = 59
	ServerScriptParserRULE_arguments               = 60
	ServerScriptParserRULE_argument                = 61
	ServerScriptParserRULE_expressionSequence      = 62
	ServerScriptParserRULE_singleExpression        = 63
	ServerScriptParserRULE_assignable              = 64
	ServerScriptParserRULE_objectLiteral           = 65
	ServerScriptParserRULE_anonymousFunction       = 66
	ServerScriptParserRULE_arrowFunctionParameters = 67
	ServerScriptParserRULE_assignmentOperator      = 68
	ServerScriptParserRULE_literal                 = 69
	ServerScriptParserRULE_templateStringLiteral   = 70
	ServerScriptParserRULE_templateStringAtom      = 71
	ServerScriptParserRULE_numericLiteral          = 72
	ServerScriptParserRULE_bigintLiteral           = 73
	ServerScriptParserRULE_identifierName          = 74
	ServerScriptParserRULE_identifier              = 75
	ServerScriptParserRULE_reservedWord            = 76
	ServerScriptParserRULE_keyword                 = 77
	ServerScriptParserRULE_eos                     = 78
)

// IProgramContext is an interface to support dynamic dispatch.
type IProgramContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EOF() antlr.TerminalNode
	HashBangLine() antlr.TerminalNode
	SourceElements() ISourceElementsContext

	// IsProgramContext differentiates from other interfaces.
	IsProgramContext()
}

type ProgramContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProgramContext() *ProgramContext {
	var p = new(ProgramContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_program
	return p
}

func InitEmptyProgramContext(p *ProgramContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_program
}

func (*ProgramContext) IsProgramContext() {}

func NewProgramContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProgramContext {
	var p = new(ProgramContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ServerScriptParserRULE_program

	return p
}

func (s *ProgramContext) GetParser() antlr.Parser { return s.parser }

func (s *ProgramContext) EOF() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserEOF, 0)
}

func (s *ProgramContext) HashBangLine() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserHashBangLine, 0)
}

func (s *ProgramContext) SourceElements() ISourceElementsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISourceElementsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISourceElementsContext)
}

func (s *ProgramContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProgramContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProgramContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.EnterProgram(s)
	}
}

func (s *ProgramContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.ExitProgram(s)
	}
}

func (s *ProgramContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ServerScriptParserVisitor:
		return t.VisitProgram(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ServerScriptParser) Program() (localctx IProgramContext) {
	localctx = NewProgramContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, ServerScriptParserRULE_program)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(159)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 0, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(158)
			p.Match(ServerScriptParserHashBangLine)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(162)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(161)
			p.SourceElements()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(164)
		p.Match(ServerScriptParserEOF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISourceElementsContext is an interface to support dynamic dispatch.
type ISourceElementsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSourceElement() []ISourceElementContext
	SourceElement(i int) ISourceElementContext

	// IsSourceElementsContext differentiates from other interfaces.
	IsSourceElementsContext()
}

type SourceElementsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySourceElementsContext() *SourceElementsContext {
	var p = new(SourceElementsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_sourceElements
	return p
}

func InitEmptySourceElementsContext(p *SourceElementsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_sourceElements
}

func (*SourceElementsContext) IsSourceElementsContext() {}

func NewSourceElementsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SourceElementsContext {
	var p = new(SourceElementsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ServerScriptParserRULE_sourceElements

	return p
}

func (s *SourceElementsContext) GetParser() antlr.Parser { return s.parser }

func (s *SourceElementsContext) AllSourceElement() []ISourceElementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISourceElementContext); ok {
			len++
		}
	}

	tst := make([]ISourceElementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISourceElementContext); ok {
			tst[i] = t.(ISourceElementContext)
			i++
		}
	}

	return tst
}

func (s *SourceElementsContext) SourceElement(i int) ISourceElementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISourceElementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISourceElementContext)
}

func (s *SourceElementsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SourceElementsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SourceElementsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.EnterSourceElements(s)
	}
}

func (s *SourceElementsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.ExitSourceElements(s)
	}
}

func (s *SourceElementsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ServerScriptParserVisitor:
		return t.VisitSourceElements(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ServerScriptParser) SourceElements() (localctx ISourceElementsContext) {
	localctx = NewSourceElementsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, ServerScriptParserRULE_sourceElements)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(167)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(166)
				p.SourceElement()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(169)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 2, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISourceElementContext is an interface to support dynamic dispatch.
type ISourceElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Statement() IStatementContext

	// IsSourceElementContext differentiates from other interfaces.
	IsSourceElementContext()
}

type SourceElementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySourceElementContext() *SourceElementContext {
	var p = new(SourceElementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_sourceElement
	return p
}

func InitEmptySourceElementContext(p *SourceElementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_sourceElement
}

func (*SourceElementContext) IsSourceElementContext() {}

func NewSourceElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SourceElementContext {
	var p = new(SourceElementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ServerScriptParserRULE_sourceElement

	return p
}

func (s *SourceElementContext) GetParser() antlr.Parser { return s.parser }

func (s *SourceElementContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *SourceElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SourceElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SourceElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.EnterSourceElement(s)
	}
}

func (s *SourceElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.ExitSourceElement(s)
	}
}

func (s *SourceElementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ServerScriptParserVisitor:
		return t.VisitSourceElement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ServerScriptParser) SourceElement() (localctx ISourceElementContext) {
	localctx = NewSourceElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, ServerScriptParserRULE_sourceElement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(171)
		p.Statement()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStatementContext is an interface to support dynamic dispatch.
type IStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Block() IBlockContext
	VariableStatement() IVariableStatementContext
	ImportStatement() IImportStatementContext
	ExportStatement() IExportStatementContext
	EmptyStatement_() IEmptyStatement_Context
	FunctionDeclaration() IFunctionDeclarationContext
	ExpressionStatement() IExpressionStatementContext
	IfStatement() IIfStatementContext
	IterationStatement() IIterationStatementContext
	ContinueStatement() IContinueStatementContext
	BreakStatement() IBreakStatementContext
	ReturnStatement() IReturnStatementContext
	SwitchStatement() ISwitchStatementContext
	ThrowStatement() IThrowStatementContext
	TryStatement() ITryStatementContext

	// IsStatementContext differentiates from other interfaces.
	IsStatementContext()
}

type StatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementContext() *StatementContext {
	var p = new(StatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_statement
	return p
}

func InitEmptyStatementContext(p *StatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_statement
}

func (*StatementContext) IsStatementContext() {}

func NewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementContext {
	var p = new(StatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ServerScriptParserRULE_statement

	return p
}

func (s *StatementContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *StatementContext) VariableStatement() IVariableStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableStatementContext)
}

func (s *StatementContext) ImportStatement() IImportStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImportStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImportStatementContext)
}

func (s *StatementContext) ExportStatement() IExportStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExportStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExportStatementContext)
}

func (s *StatementContext) EmptyStatement_() IEmptyStatement_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEmptyStatement_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEmptyStatement_Context)
}

func (s *StatementContext) FunctionDeclaration() IFunctionDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionDeclarationContext)
}

func (s *StatementContext) ExpressionStatement() IExpressionStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionStatementContext)
}

func (s *StatementContext) IfStatement() IIfStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfStatementContext)
}

func (s *StatementContext) IterationStatement() IIterationStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIterationStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIterationStatementContext)
}

func (s *StatementContext) ContinueStatement() IContinueStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IContinueStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IContinueStatementContext)
}

func (s *StatementContext) BreakStatement() IBreakStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBreakStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBreakStatementContext)
}

func (s *StatementContext) ReturnStatement() IReturnStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReturnStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReturnStatementContext)
}

func (s *StatementContext) SwitchStatement() ISwitchStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISwitchStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISwitchStatementContext)
}

func (s *StatementContext) ThrowStatement() IThrowStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IThrowStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IThrowStatementContext)
}

func (s *StatementContext) TryStatement() ITryStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITryStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITryStatementContext)
}

func (s *StatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.EnterStatement(s)
	}
}

func (s *StatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.ExitStatement(s)
	}
}

func (s *StatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ServerScriptParserVisitor:
		return t.VisitStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ServerScriptParser) Statement() (localctx IStatementContext) {
	localctx = NewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, ServerScriptParserRULE_statement)
	p.SetState(188)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 3, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(173)
			p.Block()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(174)
			p.VariableStatement()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(175)
			p.ImportStatement()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(176)
			p.ExportStatement()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(177)
			p.EmptyStatement_()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(178)
			p.FunctionDeclaration()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(179)
			p.ExpressionStatement()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(180)
			p.IfStatement()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(181)
			p.IterationStatement()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(182)
			p.ContinueStatement()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(183)
			p.BreakStatement()
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(184)
			p.ReturnStatement()
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(185)
			p.SwitchStatement()
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(186)
			p.ThrowStatement()
		}

	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(187)
			p.TryStatement()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBlockContext is an interface to support dynamic dispatch.
type IBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OpenBrace() antlr.TerminalNode
	CloseBrace() antlr.TerminalNode
	StatementList() IStatementListContext

	// IsBlockContext differentiates from other interfaces.
	IsBlockContext()
}

type BlockContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBlockContext() *BlockContext {
	var p = new(BlockContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_block
	return p
}

func InitEmptyBlockContext(p *BlockContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_block
}

func (*BlockContext) IsBlockContext() {}

func NewBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BlockContext {
	var p = new(BlockContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ServerScriptParserRULE_block

	return p
}

func (s *BlockContext) GetParser() antlr.Parser { return s.parser }

func (s *BlockContext) OpenBrace() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserOpenBrace, 0)
}

func (s *BlockContext) CloseBrace() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserCloseBrace, 0)
}

func (s *BlockContext) StatementList() IStatementListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementListContext)
}

func (s *BlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.EnterBlock(s)
	}
}

func (s *BlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.ExitBlock(s)
	}
}

func (s *BlockContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ServerScriptParserVisitor:
		return t.VisitBlock(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ServerScriptParser) Block() (localctx IBlockContext) {
	localctx = NewBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, ServerScriptParserRULE_block)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(190)
		p.Match(ServerScriptParserOpenBrace)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(192)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 4, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(191)
			p.StatementList()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(194)
		p.Match(ServerScriptParserCloseBrace)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStatementListContext is an interface to support dynamic dispatch.
type IStatementListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllStatement() []IStatementContext
	Statement(i int) IStatementContext

	// IsStatementListContext differentiates from other interfaces.
	IsStatementListContext()
}

type StatementListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementListContext() *StatementListContext {
	var p = new(StatementListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_statementList
	return p
}

func InitEmptyStatementListContext(p *StatementListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_statementList
}

func (*StatementListContext) IsStatementListContext() {}

func NewStatementListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementListContext {
	var p = new(StatementListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ServerScriptParserRULE_statementList

	return p
}

func (s *StatementListContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementListContext) AllStatement() []IStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatementContext); ok {
			len++
		}
	}

	tst := make([]IStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatementContext); ok {
			tst[i] = t.(IStatementContext)
			i++
		}
	}

	return tst
}

func (s *StatementListContext) Statement(i int) IStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *StatementListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StatementListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.EnterStatementList(s)
	}
}

func (s *StatementListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.ExitStatementList(s)
	}
}

func (s *StatementListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ServerScriptParserVisitor:
		return t.VisitStatementList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ServerScriptParser) StatementList() (localctx IStatementListContext) {
	localctx = NewStatementListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, ServerScriptParserRULE_statementList)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(197)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(196)
				p.Statement()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(199)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 5, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IImportStatementContext is an interface to support dynamic dispatch.
type IImportStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Import() antlr.TerminalNode
	ImportFromBlock() IImportFromBlockContext

	// IsImportStatementContext differentiates from other interfaces.
	IsImportStatementContext()
}

type ImportStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImportStatementContext() *ImportStatementContext {
	var p = new(ImportStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_importStatement
	return p
}

func InitEmptyImportStatementContext(p *ImportStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_importStatement
}

func (*ImportStatementContext) IsImportStatementContext() {}

func NewImportStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImportStatementContext {
	var p = new(ImportStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ServerScriptParserRULE_importStatement

	return p
}

func (s *ImportStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ImportStatementContext) Import() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserImport, 0)
}

func (s *ImportStatementContext) ImportFromBlock() IImportFromBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImportFromBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImportFromBlockContext)
}

func (s *ImportStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImportStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.EnterImportStatement(s)
	}
}

func (s *ImportStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.ExitImportStatement(s)
	}
}

func (s *ImportStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ServerScriptParserVisitor:
		return t.VisitImportStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ServerScriptParser) ImportStatement() (localctx IImportStatementContext) {
	localctx = NewImportStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, ServerScriptParserRULE_importStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(201)
		p.Match(ServerScriptParserImport)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(202)
		p.ImportFromBlock()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IImportFromBlockContext is an interface to support dynamic dispatch.
type IImportFromBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsImportFromBlockContext differentiates from other interfaces.
	IsImportFromBlockContext()
}

type ImportFromBlockContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImportFromBlockContext() *ImportFromBlockContext {
	var p = new(ImportFromBlockContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_importFromBlock
	return p
}

func InitEmptyImportFromBlockContext(p *ImportFromBlockContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_importFromBlock
}

func (*ImportFromBlockContext) IsImportFromBlockContext() {}

func NewImportFromBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImportFromBlockContext {
	var p = new(ImportFromBlockContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ServerScriptParserRULE_importFromBlock

	return p
}

func (s *ImportFromBlockContext) GetParser() antlr.Parser { return s.parser }

func (s *ImportFromBlockContext) CopyAll(ctx *ImportFromBlockContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *ImportFromBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportFromBlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ImportFromBlock2Context struct {
	ImportFromBlockContext
}

func NewImportFromBlock2Context(parser antlr.Parser, ctx antlr.ParserRuleContext) *ImportFromBlock2Context {
	var p = new(ImportFromBlock2Context)

	InitEmptyImportFromBlockContext(&p.ImportFromBlockContext)
	p.parser = parser
	p.CopyAll(ctx.(*ImportFromBlockContext))

	return p
}

func (s *ImportFromBlock2Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportFromBlock2Context) ImportModuleItems() IImportModuleItemsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImportModuleItemsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImportModuleItemsContext)
}

func (s *ImportFromBlock2Context) ImportFrom() IImportFromContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImportFromContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImportFromContext)
}

func (s *ImportFromBlock2Context) Eos() IEosContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEosContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *ImportFromBlock2Context) ImportDefault() IImportDefaultContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImportDefaultContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImportDefaultContext)
}

func (s *ImportFromBlock2Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.EnterImportFromBlock2(s)
	}
}

func (s *ImportFromBlock2Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.ExitImportFromBlock2(s)
	}
}

func (s *ImportFromBlock2Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ServerScriptParserVisitor:
		return t.VisitImportFromBlock2(s)

	default:
		return t.VisitChildren(s)
	}
}

type ImportFromBlock3Context struct {
	ImportFromBlockContext
}

func NewImportFromBlock3Context(parser antlr.Parser, ctx antlr.ParserRuleContext) *ImportFromBlock3Context {
	var p = new(ImportFromBlock3Context)

	InitEmptyImportFromBlockContext(&p.ImportFromBlockContext)
	p.parser = parser
	p.CopyAll(ctx.(*ImportFromBlockContext))

	return p
}

func (s *ImportFromBlock3Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportFromBlock3Context) IdentifierName() IIdentifierNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierNameContext)
}

func (s *ImportFromBlock3Context) ImportFrom() IImportFromContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImportFromContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImportFromContext)
}

func (s *ImportFromBlock3Context) Eos() IEosContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEosContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *ImportFromBlock3Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.EnterImportFromBlock3(s)
	}
}

func (s *ImportFromBlock3Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.ExitImportFromBlock3(s)
	}
}

func (s *ImportFromBlock3Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ServerScriptParserVisitor:
		return t.VisitImportFromBlock3(s)

	default:
		return t.VisitChildren(s)
	}
}

type ImportFromBlock1Context struct {
	ImportFromBlockContext
}

func NewImportFromBlock1Context(parser antlr.Parser, ctx antlr.ParserRuleContext) *ImportFromBlock1Context {
	var p = new(ImportFromBlock1Context)

	InitEmptyImportFromBlockContext(&p.ImportFromBlockContext)
	p.parser = parser
	p.CopyAll(ctx.(*ImportFromBlockContext))

	return p
}

func (s *ImportFromBlock1Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportFromBlock1Context) ImportNamespace() IImportNamespaceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImportNamespaceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImportNamespaceContext)
}

func (s *ImportFromBlock1Context) ImportFrom() IImportFromContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImportFromContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImportFromContext)
}

func (s *ImportFromBlock1Context) Eos() IEosContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEosContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *ImportFromBlock1Context) ImportDefault() IImportDefaultContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImportDefaultContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImportDefaultContext)
}

func (s *ImportFromBlock1Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.EnterImportFromBlock1(s)
	}
}

func (s *ImportFromBlock1Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.ExitImportFromBlock1(s)
	}
}

func (s *ImportFromBlock1Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ServerScriptParserVisitor:
		return t.VisitImportFromBlock1(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ServerScriptParser) ImportFromBlock() (localctx IImportFromBlockContext) {
	localctx = NewImportFromBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, ServerScriptParserRULE_importFromBlock)
	var _la int

	p.SetState(222)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 8, p.GetParserRuleContext()) {
	case 1:
		localctx = NewImportFromBlock1Context(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		p.SetState(205)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if (int64((_la-62)) & ^0x3f) == 0 && ((int64(1)<<(_la-62))&9223372036854759435) != 0 {
			{
				p.SetState(204)
				p.ImportDefault()
			}

		}
		{
			p.SetState(207)
			p.ImportNamespace()
		}
		{
			p.SetState(208)
			p.ImportFrom()
		}
		{
			p.SetState(209)
			p.Eos()
		}

	case 2:
		localctx = NewImportFromBlock2Context(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		p.SetState(212)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if (int64((_la-62)) & ^0x3f) == 0 && ((int64(1)<<(_la-62))&9223372036854759435) != 0 {
			{
				p.SetState(211)
				p.ImportDefault()
			}

		}
		{
			p.SetState(214)
			p.ImportModuleItems()
		}
		{
			p.SetState(215)
			p.ImportFrom()
		}
		{
			p.SetState(216)
			p.Eos()
		}

	case 3:
		localctx = NewImportFromBlock3Context(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(218)
			p.IdentifierName()
		}
		{
			p.SetState(219)
			p.ImportFrom()
		}
		{
			p.SetState(220)
			p.Eos()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IImportModuleItemsContext is an interface to support dynamic dispatch.
type IImportModuleItemsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OpenBrace() antlr.TerminalNode
	CloseBrace() antlr.TerminalNode
	AllImportAliasName() []IImportAliasNameContext
	ImportAliasName(i int) IImportAliasNameContext
	AllComma() []antlr.TerminalNode
	Comma(i int) antlr.TerminalNode

	// IsImportModuleItemsContext differentiates from other interfaces.
	IsImportModuleItemsContext()
}

type ImportModuleItemsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImportModuleItemsContext() *ImportModuleItemsContext {
	var p = new(ImportModuleItemsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_importModuleItems
	return p
}

func InitEmptyImportModuleItemsContext(p *ImportModuleItemsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_importModuleItems
}

func (*ImportModuleItemsContext) IsImportModuleItemsContext() {}

func NewImportModuleItemsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImportModuleItemsContext {
	var p = new(ImportModuleItemsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ServerScriptParserRULE_importModuleItems

	return p
}

func (s *ImportModuleItemsContext) GetParser() antlr.Parser { return s.parser }

func (s *ImportModuleItemsContext) OpenBrace() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserOpenBrace, 0)
}

func (s *ImportModuleItemsContext) CloseBrace() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserCloseBrace, 0)
}

func (s *ImportModuleItemsContext) AllImportAliasName() []IImportAliasNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IImportAliasNameContext); ok {
			len++
		}
	}

	tst := make([]IImportAliasNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IImportAliasNameContext); ok {
			tst[i] = t.(IImportAliasNameContext)
			i++
		}
	}

	return tst
}

func (s *ImportModuleItemsContext) ImportAliasName(i int) IImportAliasNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImportAliasNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImportAliasNameContext)
}

func (s *ImportModuleItemsContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(ServerScriptParserComma)
}

func (s *ImportModuleItemsContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(ServerScriptParserComma, i)
}

func (s *ImportModuleItemsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportModuleItemsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImportModuleItemsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.EnterImportModuleItems(s)
	}
}

func (s *ImportModuleItemsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.ExitImportModuleItems(s)
	}
}

func (s *ImportModuleItemsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ServerScriptParserVisitor:
		return t.VisitImportModuleItems(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ServerScriptParser) ImportModuleItems() (localctx IImportModuleItemsContext) {
	localctx = NewImportModuleItemsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, ServerScriptParserRULE_importModuleItems)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(224)
		p.Match(ServerScriptParserOpenBrace)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(230)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 9, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(225)
				p.ImportAliasName()
			}
			{
				p.SetState(226)
				p.Match(ServerScriptParserComma)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(232)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 9, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(237)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if (int64((_la-62)) & ^0x3f) == 0 && ((int64(1)<<(_la-62))&-16373) != 0 {
		{
			p.SetState(233)
			p.ImportAliasName()
		}
		p.SetState(235)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ServerScriptParserComma {
			{
				p.SetState(234)
				p.Match(ServerScriptParserComma)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	}
	{
		p.SetState(239)
		p.Match(ServerScriptParserCloseBrace)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IImportAliasNameContext is an interface to support dynamic dispatch.
type IImportAliasNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ModuleExportName() IModuleExportNameContext
	As() antlr.TerminalNode
	ImportedBinding() IImportedBindingContext

	// IsImportAliasNameContext differentiates from other interfaces.
	IsImportAliasNameContext()
}

type ImportAliasNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImportAliasNameContext() *ImportAliasNameContext {
	var p = new(ImportAliasNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_importAliasName
	return p
}

func InitEmptyImportAliasNameContext(p *ImportAliasNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_importAliasName
}

func (*ImportAliasNameContext) IsImportAliasNameContext() {}

func NewImportAliasNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImportAliasNameContext {
	var p = new(ImportAliasNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ServerScriptParserRULE_importAliasName

	return p
}

func (s *ImportAliasNameContext) GetParser() antlr.Parser { return s.parser }

func (s *ImportAliasNameContext) ModuleExportName() IModuleExportNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModuleExportNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModuleExportNameContext)
}

func (s *ImportAliasNameContext) As() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserAs, 0)
}

func (s *ImportAliasNameContext) ImportedBinding() IImportedBindingContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImportedBindingContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImportedBindingContext)
}

func (s *ImportAliasNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportAliasNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImportAliasNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.EnterImportAliasName(s)
	}
}

func (s *ImportAliasNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.ExitImportAliasName(s)
	}
}

func (s *ImportAliasNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ServerScriptParserVisitor:
		return t.VisitImportAliasName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ServerScriptParser) ImportAliasName() (localctx IImportAliasNameContext) {
	localctx = NewImportAliasNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, ServerScriptParserRULE_importAliasName)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(241)
		p.ModuleExportName()
	}
	p.SetState(244)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ServerScriptParserAs {
		{
			p.SetState(242)
			p.Match(ServerScriptParserAs)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(243)
			p.ImportedBinding()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IModuleExportNameContext is an interface to support dynamic dispatch.
type IModuleExportNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IdentifierName() IIdentifierNameContext
	StringLiteral() antlr.TerminalNode

	// IsModuleExportNameContext differentiates from other interfaces.
	IsModuleExportNameContext()
}

type ModuleExportNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModuleExportNameContext() *ModuleExportNameContext {
	var p = new(ModuleExportNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_moduleExportName
	return p
}

func InitEmptyModuleExportNameContext(p *ModuleExportNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_moduleExportName
}

func (*ModuleExportNameContext) IsModuleExportNameContext() {}

func NewModuleExportNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModuleExportNameContext {
	var p = new(ModuleExportNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ServerScriptParserRULE_moduleExportName

	return p
}

func (s *ModuleExportNameContext) GetParser() antlr.Parser { return s.parser }

func (s *ModuleExportNameContext) IdentifierName() IIdentifierNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierNameContext)
}

func (s *ModuleExportNameContext) StringLiteral() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserStringLiteral, 0)
}

func (s *ModuleExportNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModuleExportNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ModuleExportNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.EnterModuleExportName(s)
	}
}

func (s *ModuleExportNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.ExitModuleExportName(s)
	}
}

func (s *ModuleExportNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ServerScriptParserVisitor:
		return t.VisitModuleExportName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ServerScriptParser) ModuleExportName() (localctx IModuleExportNameContext) {
	localctx = NewModuleExportNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, ServerScriptParserRULE_moduleExportName)
	p.SetState(248)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ServerScriptParserNullLiteral, ServerScriptParserNaNLiteral, ServerScriptParserBooleanLiteral, ServerScriptParserBreak, ServerScriptParserDo, ServerScriptParserInstanceof, ServerScriptParserTypeof, ServerScriptParserCase, ServerScriptParserElse, ServerScriptParserNew, ServerScriptParserVar, ServerScriptParserLet, ServerScriptParserCatch, ServerScriptParserFinally, ServerScriptParserReturn, ServerScriptParserVoid, ServerScriptParserContinue, ServerScriptParserFor, ServerScriptParserSwitch, ServerScriptParserWhile, ServerScriptParserDebugger, ServerScriptParserFunction_, ServerScriptParserThis, ServerScriptParserWith, ServerScriptParserDefault, ServerScriptParserIf, ServerScriptParserThrow, ServerScriptParserDelete, ServerScriptParserIn, ServerScriptParserTry, ServerScriptParserAs, ServerScriptParserFrom, ServerScriptParserOf, ServerScriptParserClass, ServerScriptParserEnum, ServerScriptParserExtends, ServerScriptParserSuper, ServerScriptParserConst, ServerScriptParserExport, ServerScriptParserImport, ServerScriptParserAsync, ServerScriptParserSync, ServerScriptParserAwait, ServerScriptParserYield, ServerScriptParserImplements, ServerScriptParserPrivate, ServerScriptParserPublic, ServerScriptParserInterface, ServerScriptParserPackage, ServerScriptParserProtected, ServerScriptParserStatic, ServerScriptParserIdentifier:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(246)
			p.IdentifierName()
		}

	case ServerScriptParserStringLiteral:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(247)
			p.Match(ServerScriptParserStringLiteral)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IImportedBindingContext is an interface to support dynamic dispatch.
type IImportedBindingContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() antlr.TerminalNode
	Yield() antlr.TerminalNode
	Await() antlr.TerminalNode

	// IsImportedBindingContext differentiates from other interfaces.
	IsImportedBindingContext()
}

type ImportedBindingContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImportedBindingContext() *ImportedBindingContext {
	var p = new(ImportedBindingContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_importedBinding
	return p
}

func InitEmptyImportedBindingContext(p *ImportedBindingContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_importedBinding
}

func (*ImportedBindingContext) IsImportedBindingContext() {}

func NewImportedBindingContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImportedBindingContext {
	var p = new(ImportedBindingContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ServerScriptParserRULE_importedBinding

	return p
}

func (s *ImportedBindingContext) GetParser() antlr.Parser { return s.parser }

func (s *ImportedBindingContext) Identifier() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserIdentifier, 0)
}

func (s *ImportedBindingContext) Yield() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserYield, 0)
}

func (s *ImportedBindingContext) Await() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserAwait, 0)
}

func (s *ImportedBindingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportedBindingContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImportedBindingContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.EnterImportedBinding(s)
	}
}

func (s *ImportedBindingContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.ExitImportedBinding(s)
	}
}

func (s *ImportedBindingContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ServerScriptParserVisitor:
		return t.VisitImportedBinding(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ServerScriptParser) ImportedBinding() (localctx IImportedBindingContext) {
	localctx = NewImportedBindingContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, ServerScriptParserRULE_importedBinding)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(250)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-115)) & ^0x3f) == 0 && ((int64(1)<<(_la-115))&515) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IImportDefaultContext is an interface to support dynamic dispatch.
type IImportDefaultContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AliasName() IAliasNameContext
	Comma() antlr.TerminalNode

	// IsImportDefaultContext differentiates from other interfaces.
	IsImportDefaultContext()
}

type ImportDefaultContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImportDefaultContext() *ImportDefaultContext {
	var p = new(ImportDefaultContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_importDefault
	return p
}

func InitEmptyImportDefaultContext(p *ImportDefaultContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_importDefault
}

func (*ImportDefaultContext) IsImportDefaultContext() {}

func NewImportDefaultContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImportDefaultContext {
	var p = new(ImportDefaultContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ServerScriptParserRULE_importDefault

	return p
}

func (s *ImportDefaultContext) GetParser() antlr.Parser { return s.parser }

func (s *ImportDefaultContext) AliasName() IAliasNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAliasNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAliasNameContext)
}

func (s *ImportDefaultContext) Comma() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserComma, 0)
}

func (s *ImportDefaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportDefaultContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImportDefaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.EnterImportDefault(s)
	}
}

func (s *ImportDefaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.ExitImportDefault(s)
	}
}

func (s *ImportDefaultContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ServerScriptParserVisitor:
		return t.VisitImportDefault(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ServerScriptParser) ImportDefault() (localctx IImportDefaultContext) {
	localctx = NewImportDefaultContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, ServerScriptParserRULE_importDefault)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(252)
		p.AliasName()
	}
	{
		p.SetState(253)
		p.Match(ServerScriptParserComma)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IImportNamespaceContext is an interface to support dynamic dispatch.
type IImportNamespaceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Multiply() antlr.TerminalNode
	As() antlr.TerminalNode
	IdentifierName() IIdentifierNameContext

	// IsImportNamespaceContext differentiates from other interfaces.
	IsImportNamespaceContext()
}

type ImportNamespaceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImportNamespaceContext() *ImportNamespaceContext {
	var p = new(ImportNamespaceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_importNamespace
	return p
}

func InitEmptyImportNamespaceContext(p *ImportNamespaceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_importNamespace
}

func (*ImportNamespaceContext) IsImportNamespaceContext() {}

func NewImportNamespaceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImportNamespaceContext {
	var p = new(ImportNamespaceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ServerScriptParserRULE_importNamespace

	return p
}

func (s *ImportNamespaceContext) GetParser() antlr.Parser { return s.parser }

func (s *ImportNamespaceContext) Multiply() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserMultiply, 0)
}

func (s *ImportNamespaceContext) As() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserAs, 0)
}

func (s *ImportNamespaceContext) IdentifierName() IIdentifierNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierNameContext)
}

func (s *ImportNamespaceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportNamespaceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImportNamespaceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.EnterImportNamespace(s)
	}
}

func (s *ImportNamespaceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.ExitImportNamespace(s)
	}
}

func (s *ImportNamespaceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ServerScriptParserVisitor:
		return t.VisitImportNamespace(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ServerScriptParser) ImportNamespace() (localctx IImportNamespaceContext) {
	localctx = NewImportNamespaceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, ServerScriptParserRULE_importNamespace)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(255)
		p.Match(ServerScriptParserMultiply)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(256)
		p.Match(ServerScriptParserAs)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(257)
		p.IdentifierName()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IImportFromContext is an interface to support dynamic dispatch.
type IImportFromContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	From() antlr.TerminalNode
	StringLiteral() antlr.TerminalNode

	// IsImportFromContext differentiates from other interfaces.
	IsImportFromContext()
}

type ImportFromContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImportFromContext() *ImportFromContext {
	var p = new(ImportFromContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_importFrom
	return p
}

func InitEmptyImportFromContext(p *ImportFromContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_importFrom
}

func (*ImportFromContext) IsImportFromContext() {}

func NewImportFromContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImportFromContext {
	var p = new(ImportFromContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ServerScriptParserRULE_importFrom

	return p
}

func (s *ImportFromContext) GetParser() antlr.Parser { return s.parser }

func (s *ImportFromContext) From() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserFrom, 0)
}

func (s *ImportFromContext) StringLiteral() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserStringLiteral, 0)
}

func (s *ImportFromContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportFromContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImportFromContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.EnterImportFrom(s)
	}
}

func (s *ImportFromContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.ExitImportFrom(s)
	}
}

func (s *ImportFromContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ServerScriptParserVisitor:
		return t.VisitImportFrom(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ServerScriptParser) ImportFrom() (localctx IImportFromContext) {
	localctx = NewImportFromContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, ServerScriptParserRULE_importFrom)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(259)
		p.Match(ServerScriptParserFrom)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(260)
		p.Match(ServerScriptParserStringLiteral)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAliasNameContext is an interface to support dynamic dispatch.
type IAliasNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIdentifierName() []IIdentifierNameContext
	IdentifierName(i int) IIdentifierNameContext
	As() antlr.TerminalNode

	// IsAliasNameContext differentiates from other interfaces.
	IsAliasNameContext()
}

type AliasNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAliasNameContext() *AliasNameContext {
	var p = new(AliasNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_aliasName
	return p
}

func InitEmptyAliasNameContext(p *AliasNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_aliasName
}

func (*AliasNameContext) IsAliasNameContext() {}

func NewAliasNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AliasNameContext {
	var p = new(AliasNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ServerScriptParserRULE_aliasName

	return p
}

func (s *AliasNameContext) GetParser() antlr.Parser { return s.parser }

func (s *AliasNameContext) AllIdentifierName() []IIdentifierNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierNameContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierNameContext); ok {
			tst[i] = t.(IIdentifierNameContext)
			i++
		}
	}

	return tst
}

func (s *AliasNameContext) IdentifierName(i int) IIdentifierNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierNameContext)
}

func (s *AliasNameContext) As() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserAs, 0)
}

func (s *AliasNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AliasNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AliasNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.EnterAliasName(s)
	}
}

func (s *AliasNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.ExitAliasName(s)
	}
}

func (s *AliasNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ServerScriptParserVisitor:
		return t.VisitAliasName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ServerScriptParser) AliasName() (localctx IAliasNameContext) {
	localctx = NewAliasNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, ServerScriptParserRULE_aliasName)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(262)
		p.IdentifierName()
	}
	p.SetState(265)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ServerScriptParserAs {
		{
			p.SetState(263)
			p.Match(ServerScriptParserAs)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(264)
			p.IdentifierName()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExportStatementContext is an interface to support dynamic dispatch.
type IExportStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsExportStatementContext differentiates from other interfaces.
	IsExportStatementContext()
}

type ExportStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExportStatementContext() *ExportStatementContext {
	var p = new(ExportStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_exportStatement
	return p
}

func InitEmptyExportStatementContext(p *ExportStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_exportStatement
}

func (*ExportStatementContext) IsExportStatementContext() {}

func NewExportStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExportStatementContext {
	var p = new(ExportStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ServerScriptParserRULE_exportStatement

	return p
}

func (s *ExportStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ExportStatementContext) CopyAll(ctx *ExportStatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *ExportStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExportStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ExportDefaultDeclarationContext struct {
	ExportStatementContext
}

func NewExportDefaultDeclarationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExportDefaultDeclarationContext {
	var p = new(ExportDefaultDeclarationContext)

	InitEmptyExportStatementContext(&p.ExportStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExportStatementContext))

	return p
}

func (s *ExportDefaultDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExportDefaultDeclarationContext) Export() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserExport, 0)
}

func (s *ExportDefaultDeclarationContext) Default() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserDefault, 0)
}

func (s *ExportDefaultDeclarationContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *ExportDefaultDeclarationContext) Eos() IEosContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEosContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *ExportDefaultDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.EnterExportDefaultDeclaration(s)
	}
}

func (s *ExportDefaultDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.ExitExportDefaultDeclaration(s)
	}
}

func (s *ExportDefaultDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ServerScriptParserVisitor:
		return t.VisitExportDefaultDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

type ExportBlockContext struct {
	ExportStatementContext
}

func NewExportBlockContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExportBlockContext {
	var p = new(ExportBlockContext)

	InitEmptyExportStatementContext(&p.ExportStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExportStatementContext))

	return p
}

func (s *ExportBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExportBlockContext) Export() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserExport, 0)
}

func (s *ExportBlockContext) ExportFromBlock() IExportFromBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExportFromBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExportFromBlockContext)
}

func (s *ExportBlockContext) Eos() IEosContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEosContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *ExportBlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.EnterExportBlock(s)
	}
}

func (s *ExportBlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.ExitExportBlock(s)
	}
}

func (s *ExportBlockContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ServerScriptParserVisitor:
		return t.VisitExportBlock(s)

	default:
		return t.VisitChildren(s)
	}
}

type ExportItemsContext struct {
	ExportStatementContext
}

func NewExportItemsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExportItemsContext {
	var p = new(ExportItemsContext)

	InitEmptyExportStatementContext(&p.ExportStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExportStatementContext))

	return p
}

func (s *ExportItemsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExportItemsContext) Export() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserExport, 0)
}

func (s *ExportItemsContext) ExportModuleItems() IExportModuleItemsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExportModuleItemsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExportModuleItemsContext)
}

func (s *ExportItemsContext) Eos() IEosContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEosContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *ExportItemsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.EnterExportItems(s)
	}
}

func (s *ExportItemsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.ExitExportItems(s)
	}
}

func (s *ExportItemsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ServerScriptParserVisitor:
		return t.VisitExportItems(s)

	default:
		return t.VisitChildren(s)
	}
}

type ExportDeclarationContext struct {
	ExportStatementContext
}

func NewExportDeclarationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExportDeclarationContext {
	var p = new(ExportDeclarationContext)

	InitEmptyExportStatementContext(&p.ExportStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExportStatementContext))

	return p
}

func (s *ExportDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExportDeclarationContext) Export() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserExport, 0)
}

func (s *ExportDeclarationContext) Declaration() IDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclarationContext)
}

func (s *ExportDeclarationContext) Eos() IEosContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEosContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *ExportDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.EnterExportDeclaration(s)
	}
}

func (s *ExportDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.ExitExportDeclaration(s)
	}
}

func (s *ExportDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ServerScriptParserVisitor:
		return t.VisitExportDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ServerScriptParser) ExportStatement() (localctx IExportStatementContext) {
	localctx = NewExportStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, ServerScriptParserRULE_exportStatement)
	p.SetState(284)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 15, p.GetParserRuleContext()) {
	case 1:
		localctx = NewExportDeclarationContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(267)
			p.Match(ServerScriptParserExport)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(268)
			p.Declaration()
		}
		{
			p.SetState(269)
			p.Eos()
		}

	case 2:
		localctx = NewExportItemsContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(271)
			p.Match(ServerScriptParserExport)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(272)
			p.ExportModuleItems()
		}
		{
			p.SetState(273)
			p.Eos()
		}

	case 3:
		localctx = NewExportBlockContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(275)
			p.Match(ServerScriptParserExport)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(276)
			p.ExportFromBlock()
		}
		{
			p.SetState(277)
			p.Eos()
		}

	case 4:
		localctx = NewExportDefaultDeclarationContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(279)
			p.Match(ServerScriptParserExport)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(280)
			p.Match(ServerScriptParserDefault)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(281)
			p.singleExpression(0)
		}
		{
			p.SetState(282)
			p.Eos()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExportNamespaceContext is an interface to support dynamic dispatch.
type IExportNamespaceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIdentifierName() []IIdentifierNameContext
	IdentifierName(i int) IIdentifierNameContext
	As() antlr.TerminalNode

	// IsExportNamespaceContext differentiates from other interfaces.
	IsExportNamespaceContext()
}

type ExportNamespaceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExportNamespaceContext() *ExportNamespaceContext {
	var p = new(ExportNamespaceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_exportNamespace
	return p
}

func InitEmptyExportNamespaceContext(p *ExportNamespaceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_exportNamespace
}

func (*ExportNamespaceContext) IsExportNamespaceContext() {}

func NewExportNamespaceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExportNamespaceContext {
	var p = new(ExportNamespaceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ServerScriptParserRULE_exportNamespace

	return p
}

func (s *ExportNamespaceContext) GetParser() antlr.Parser { return s.parser }

func (s *ExportNamespaceContext) AllIdentifierName() []IIdentifierNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierNameContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierNameContext); ok {
			tst[i] = t.(IIdentifierNameContext)
			i++
		}
	}

	return tst
}

func (s *ExportNamespaceContext) IdentifierName(i int) IIdentifierNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierNameContext)
}

func (s *ExportNamespaceContext) As() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserAs, 0)
}

func (s *ExportNamespaceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExportNamespaceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExportNamespaceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.EnterExportNamespace(s)
	}
}

func (s *ExportNamespaceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.ExitExportNamespace(s)
	}
}

func (s *ExportNamespaceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ServerScriptParserVisitor:
		return t.VisitExportNamespace(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ServerScriptParser) ExportNamespace() (localctx IExportNamespaceContext) {
	localctx = NewExportNamespaceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, ServerScriptParserRULE_exportNamespace)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(286)
		p.IdentifierName()
	}
	p.SetState(289)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ServerScriptParserAs {
		{
			p.SetState(287)
			p.Match(ServerScriptParserAs)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(288)
			p.IdentifierName()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExportFromBlockContext is an interface to support dynamic dispatch.
type IExportFromBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ExportNamespace() IExportNamespaceContext
	ImportFrom() IImportFromContext
	Eos() IEosContext

	// IsExportFromBlockContext differentiates from other interfaces.
	IsExportFromBlockContext()
}

type ExportFromBlockContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExportFromBlockContext() *ExportFromBlockContext {
	var p = new(ExportFromBlockContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_exportFromBlock
	return p
}

func InitEmptyExportFromBlockContext(p *ExportFromBlockContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_exportFromBlock
}

func (*ExportFromBlockContext) IsExportFromBlockContext() {}

func NewExportFromBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExportFromBlockContext {
	var p = new(ExportFromBlockContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ServerScriptParserRULE_exportFromBlock

	return p
}

func (s *ExportFromBlockContext) GetParser() antlr.Parser { return s.parser }

func (s *ExportFromBlockContext) ExportNamespace() IExportNamespaceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExportNamespaceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExportNamespaceContext)
}

func (s *ExportFromBlockContext) ImportFrom() IImportFromContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImportFromContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImportFromContext)
}

func (s *ExportFromBlockContext) Eos() IEosContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEosContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *ExportFromBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExportFromBlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExportFromBlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.EnterExportFromBlock(s)
	}
}

func (s *ExportFromBlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.ExitExportFromBlock(s)
	}
}

func (s *ExportFromBlockContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ServerScriptParserVisitor:
		return t.VisitExportFromBlock(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ServerScriptParser) ExportFromBlock() (localctx IExportFromBlockContext) {
	localctx = NewExportFromBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, ServerScriptParserRULE_exportFromBlock)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(291)
		p.ExportNamespace()
	}
	{
		p.SetState(292)
		p.ImportFrom()
	}
	{
		p.SetState(293)
		p.Eos()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExportModuleItemsContext is an interface to support dynamic dispatch.
type IExportModuleItemsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OpenBrace() antlr.TerminalNode
	CloseBrace() antlr.TerminalNode
	AllExportAliasName() []IExportAliasNameContext
	ExportAliasName(i int) IExportAliasNameContext
	AllComma() []antlr.TerminalNode
	Comma(i int) antlr.TerminalNode

	// IsExportModuleItemsContext differentiates from other interfaces.
	IsExportModuleItemsContext()
}

type ExportModuleItemsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExportModuleItemsContext() *ExportModuleItemsContext {
	var p = new(ExportModuleItemsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_exportModuleItems
	return p
}

func InitEmptyExportModuleItemsContext(p *ExportModuleItemsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_exportModuleItems
}

func (*ExportModuleItemsContext) IsExportModuleItemsContext() {}

func NewExportModuleItemsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExportModuleItemsContext {
	var p = new(ExportModuleItemsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ServerScriptParserRULE_exportModuleItems

	return p
}

func (s *ExportModuleItemsContext) GetParser() antlr.Parser { return s.parser }

func (s *ExportModuleItemsContext) OpenBrace() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserOpenBrace, 0)
}

func (s *ExportModuleItemsContext) CloseBrace() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserCloseBrace, 0)
}

func (s *ExportModuleItemsContext) AllExportAliasName() []IExportAliasNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExportAliasNameContext); ok {
			len++
		}
	}

	tst := make([]IExportAliasNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExportAliasNameContext); ok {
			tst[i] = t.(IExportAliasNameContext)
			i++
		}
	}

	return tst
}

func (s *ExportModuleItemsContext) ExportAliasName(i int) IExportAliasNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExportAliasNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExportAliasNameContext)
}

func (s *ExportModuleItemsContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(ServerScriptParserComma)
}

func (s *ExportModuleItemsContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(ServerScriptParserComma, i)
}

func (s *ExportModuleItemsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExportModuleItemsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExportModuleItemsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.EnterExportModuleItems(s)
	}
}

func (s *ExportModuleItemsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.ExitExportModuleItems(s)
	}
}

func (s *ExportModuleItemsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ServerScriptParserVisitor:
		return t.VisitExportModuleItems(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ServerScriptParser) ExportModuleItems() (localctx IExportModuleItemsContext) {
	localctx = NewExportModuleItemsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, ServerScriptParserRULE_exportModuleItems)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(295)
		p.Match(ServerScriptParserOpenBrace)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(301)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 17, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(296)
				p.ExportAliasName()
			}
			{
				p.SetState(297)
				p.Match(ServerScriptParserComma)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(303)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 17, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(308)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if (int64((_la-62)) & ^0x3f) == 0 && ((int64(1)<<(_la-62))&-16373) != 0 {
		{
			p.SetState(304)
			p.ExportAliasName()
		}
		p.SetState(306)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ServerScriptParserComma {
			{
				p.SetState(305)
				p.Match(ServerScriptParserComma)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	}
	{
		p.SetState(310)
		p.Match(ServerScriptParserCloseBrace)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExportAliasNameContext is an interface to support dynamic dispatch.
type IExportAliasNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllModuleExportName() []IModuleExportNameContext
	ModuleExportName(i int) IModuleExportNameContext
	As() antlr.TerminalNode

	// IsExportAliasNameContext differentiates from other interfaces.
	IsExportAliasNameContext()
}

type ExportAliasNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExportAliasNameContext() *ExportAliasNameContext {
	var p = new(ExportAliasNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_exportAliasName
	return p
}

func InitEmptyExportAliasNameContext(p *ExportAliasNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_exportAliasName
}

func (*ExportAliasNameContext) IsExportAliasNameContext() {}

func NewExportAliasNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExportAliasNameContext {
	var p = new(ExportAliasNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ServerScriptParserRULE_exportAliasName

	return p
}

func (s *ExportAliasNameContext) GetParser() antlr.Parser { return s.parser }

func (s *ExportAliasNameContext) AllModuleExportName() []IModuleExportNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IModuleExportNameContext); ok {
			len++
		}
	}

	tst := make([]IModuleExportNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IModuleExportNameContext); ok {
			tst[i] = t.(IModuleExportNameContext)
			i++
		}
	}

	return tst
}

func (s *ExportAliasNameContext) ModuleExportName(i int) IModuleExportNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModuleExportNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModuleExportNameContext)
}

func (s *ExportAliasNameContext) As() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserAs, 0)
}

func (s *ExportAliasNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExportAliasNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExportAliasNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.EnterExportAliasName(s)
	}
}

func (s *ExportAliasNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.ExitExportAliasName(s)
	}
}

func (s *ExportAliasNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ServerScriptParserVisitor:
		return t.VisitExportAliasName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ServerScriptParser) ExportAliasName() (localctx IExportAliasNameContext) {
	localctx = NewExportAliasNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, ServerScriptParserRULE_exportAliasName)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(312)
		p.ModuleExportName()
	}
	p.SetState(315)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ServerScriptParserAs {
		{
			p.SetState(313)
			p.Match(ServerScriptParserAs)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(314)
			p.ModuleExportName()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDeclarationContext is an interface to support dynamic dispatch.
type IDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	VariableStatement() IVariableStatementContext
	FunctionDeclaration() IFunctionDeclarationContext

	// IsDeclarationContext differentiates from other interfaces.
	IsDeclarationContext()
}

type DeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeclarationContext() *DeclarationContext {
	var p = new(DeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_declaration
	return p
}

func InitEmptyDeclarationContext(p *DeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_declaration
}

func (*DeclarationContext) IsDeclarationContext() {}

func NewDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeclarationContext {
	var p = new(DeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ServerScriptParserRULE_declaration

	return p
}

func (s *DeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *DeclarationContext) VariableStatement() IVariableStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableStatementContext)
}

func (s *DeclarationContext) FunctionDeclaration() IFunctionDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionDeclarationContext)
}

func (s *DeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.EnterDeclaration(s)
	}
}

func (s *DeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.ExitDeclaration(s)
	}
}

func (s *DeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ServerScriptParserVisitor:
		return t.VisitDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ServerScriptParser) Declaration() (localctx IDeclarationContext) {
	localctx = NewDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, ServerScriptParserRULE_declaration)
	p.SetState(319)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ServerScriptParserLet, ServerScriptParserConst:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(317)
			p.VariableStatement()
		}

	case ServerScriptParserFunction_:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(318)
			p.FunctionDeclaration()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVariableStatementContext is an interface to support dynamic dispatch.
type IVariableStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	VariableDeclarationList() IVariableDeclarationListContext
	Eos() IEosContext

	// IsVariableStatementContext differentiates from other interfaces.
	IsVariableStatementContext()
}

type VariableStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableStatementContext() *VariableStatementContext {
	var p = new(VariableStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_variableStatement
	return p
}

func InitEmptyVariableStatementContext(p *VariableStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_variableStatement
}

func (*VariableStatementContext) IsVariableStatementContext() {}

func NewVariableStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableStatementContext {
	var p = new(VariableStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ServerScriptParserRULE_variableStatement

	return p
}

func (s *VariableStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableStatementContext) VariableDeclarationList() IVariableDeclarationListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableDeclarationListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableDeclarationListContext)
}

func (s *VariableStatementContext) Eos() IEosContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEosContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *VariableStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.EnterVariableStatement(s)
	}
}

func (s *VariableStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.ExitVariableStatement(s)
	}
}

func (s *VariableStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ServerScriptParserVisitor:
		return t.VisitVariableStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ServerScriptParser) VariableStatement() (localctx IVariableStatementContext) {
	localctx = NewVariableStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, ServerScriptParserRULE_variableStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(321)
		p.VariableDeclarationList()
	}
	{
		p.SetState(322)
		p.Eos()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVariableDeclarationListContext is an interface to support dynamic dispatch.
type IVariableDeclarationListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	VarModifier() IVarModifierContext
	AllVariableDeclaration() []IVariableDeclarationContext
	VariableDeclaration(i int) IVariableDeclarationContext
	AllComma() []antlr.TerminalNode
	Comma(i int) antlr.TerminalNode

	// IsVariableDeclarationListContext differentiates from other interfaces.
	IsVariableDeclarationListContext()
}

type VariableDeclarationListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableDeclarationListContext() *VariableDeclarationListContext {
	var p = new(VariableDeclarationListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_variableDeclarationList
	return p
}

func InitEmptyVariableDeclarationListContext(p *VariableDeclarationListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_variableDeclarationList
}

func (*VariableDeclarationListContext) IsVariableDeclarationListContext() {}

func NewVariableDeclarationListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableDeclarationListContext {
	var p = new(VariableDeclarationListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ServerScriptParserRULE_variableDeclarationList

	return p
}

func (s *VariableDeclarationListContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableDeclarationListContext) VarModifier() IVarModifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVarModifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVarModifierContext)
}

func (s *VariableDeclarationListContext) AllVariableDeclaration() []IVariableDeclarationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IVariableDeclarationContext); ok {
			len++
		}
	}

	tst := make([]IVariableDeclarationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IVariableDeclarationContext); ok {
			tst[i] = t.(IVariableDeclarationContext)
			i++
		}
	}

	return tst
}

func (s *VariableDeclarationListContext) VariableDeclaration(i int) IVariableDeclarationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableDeclarationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableDeclarationContext)
}

func (s *VariableDeclarationListContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(ServerScriptParserComma)
}

func (s *VariableDeclarationListContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(ServerScriptParserComma, i)
}

func (s *VariableDeclarationListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableDeclarationListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableDeclarationListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.EnterVariableDeclarationList(s)
	}
}

func (s *VariableDeclarationListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.ExitVariableDeclarationList(s)
	}
}

func (s *VariableDeclarationListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ServerScriptParserVisitor:
		return t.VisitVariableDeclarationList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ServerScriptParser) VariableDeclarationList() (localctx IVariableDeclarationListContext) {
	localctx = NewVariableDeclarationListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, ServerScriptParserRULE_variableDeclarationList)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(324)
		p.VarModifier()
	}
	{
		p.SetState(325)
		p.VariableDeclaration()
	}
	p.SetState(330)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 22, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(326)
				p.Match(ServerScriptParserComma)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(327)
				p.VariableDeclaration()
			}

		}
		p.SetState(332)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 22, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVariableDeclarationContext is an interface to support dynamic dispatch.
type IVariableDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Assignable() IAssignableContext
	Assign() antlr.TerminalNode
	SingleExpression() ISingleExpressionContext

	// IsVariableDeclarationContext differentiates from other interfaces.
	IsVariableDeclarationContext()
}

type VariableDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableDeclarationContext() *VariableDeclarationContext {
	var p = new(VariableDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_variableDeclaration
	return p
}

func InitEmptyVariableDeclarationContext(p *VariableDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_variableDeclaration
}

func (*VariableDeclarationContext) IsVariableDeclarationContext() {}

func NewVariableDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableDeclarationContext {
	var p = new(VariableDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ServerScriptParserRULE_variableDeclaration

	return p
}

func (s *VariableDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableDeclarationContext) Assignable() IAssignableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignableContext)
}

func (s *VariableDeclarationContext) Assign() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserAssign, 0)
}

func (s *VariableDeclarationContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *VariableDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.EnterVariableDeclaration(s)
	}
}

func (s *VariableDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.ExitVariableDeclaration(s)
	}
}

func (s *VariableDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ServerScriptParserVisitor:
		return t.VisitVariableDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ServerScriptParser) VariableDeclaration() (localctx IVariableDeclarationContext) {
	localctx = NewVariableDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, ServerScriptParserRULE_variableDeclaration)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(333)
		p.Assignable()
	}
	p.SetState(336)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 23, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(334)
			p.Match(ServerScriptParserAssign)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(335)
			p.singleExpression(0)
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEmptyStatement_Context is an interface to support dynamic dispatch.
type IEmptyStatement_Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SemiColon() antlr.TerminalNode

	// IsEmptyStatement_Context differentiates from other interfaces.
	IsEmptyStatement_Context()
}

type EmptyStatement_Context struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEmptyStatement_Context() *EmptyStatement_Context {
	var p = new(EmptyStatement_Context)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_emptyStatement_
	return p
}

func InitEmptyEmptyStatement_Context(p *EmptyStatement_Context) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_emptyStatement_
}

func (*EmptyStatement_Context) IsEmptyStatement_Context() {}

func NewEmptyStatement_Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EmptyStatement_Context {
	var p = new(EmptyStatement_Context)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ServerScriptParserRULE_emptyStatement_

	return p
}

func (s *EmptyStatement_Context) GetParser() antlr.Parser { return s.parser }

func (s *EmptyStatement_Context) SemiColon() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserSemiColon, 0)
}

func (s *EmptyStatement_Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EmptyStatement_Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EmptyStatement_Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.EnterEmptyStatement_(s)
	}
}

func (s *EmptyStatement_Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.ExitEmptyStatement_(s)
	}
}

func (s *EmptyStatement_Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ServerScriptParserVisitor:
		return t.VisitEmptyStatement_(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ServerScriptParser) EmptyStatement_() (localctx IEmptyStatement_Context) {
	localctx = NewEmptyStatement_Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, ServerScriptParserRULE_emptyStatement_)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(338)
		p.Match(ServerScriptParserSemiColon)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpressionStatementContext is an interface to support dynamic dispatch.
type IExpressionStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ExpressionSequence() IExpressionSequenceContext
	Eos() IEosContext

	// IsExpressionStatementContext differentiates from other interfaces.
	IsExpressionStatementContext()
}

type ExpressionStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionStatementContext() *ExpressionStatementContext {
	var p = new(ExpressionStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_expressionStatement
	return p
}

func InitEmptyExpressionStatementContext(p *ExpressionStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_expressionStatement
}

func (*ExpressionStatementContext) IsExpressionStatementContext() {}

func NewExpressionStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionStatementContext {
	var p = new(ExpressionStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ServerScriptParserRULE_expressionStatement

	return p
}

func (s *ExpressionStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionStatementContext) ExpressionSequence() IExpressionSequenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionSequenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionSequenceContext)
}

func (s *ExpressionStatementContext) Eos() IEosContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEosContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *ExpressionStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.EnterExpressionStatement(s)
	}
}

func (s *ExpressionStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.ExitExpressionStatement(s)
	}
}

func (s *ExpressionStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ServerScriptParserVisitor:
		return t.VisitExpressionStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ServerScriptParser) ExpressionStatement() (localctx IExpressionStatementContext) {
	localctx = NewExpressionStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, ServerScriptParserRULE_expressionStatement)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(340)

	if !(p.notOpenBraceAndNotFunction()) {
		p.SetError(antlr.NewFailedPredicateException(p, "p.notOpenBraceAndNotFunction()", ""))
		goto errorExit
	}
	{
		p.SetState(341)
		p.ExpressionSequence()
	}
	{
		p.SetState(342)
		p.Eos()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIfStatementContext is an interface to support dynamic dispatch.
type IIfStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IfBlock() IIfBlockContext
	AllElseIfBlock() []IElseIfBlockContext
	ElseIfBlock(i int) IElseIfBlockContext
	ElseBlock() IElseBlockContext

	// IsIfStatementContext differentiates from other interfaces.
	IsIfStatementContext()
}

type IfStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIfStatementContext() *IfStatementContext {
	var p = new(IfStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_ifStatement
	return p
}

func InitEmptyIfStatementContext(p *IfStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_ifStatement
}

func (*IfStatementContext) IsIfStatementContext() {}

func NewIfStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IfStatementContext {
	var p = new(IfStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ServerScriptParserRULE_ifStatement

	return p
}

func (s *IfStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *IfStatementContext) IfBlock() IIfBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfBlockContext)
}

func (s *IfStatementContext) AllElseIfBlock() []IElseIfBlockContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IElseIfBlockContext); ok {
			len++
		}
	}

	tst := make([]IElseIfBlockContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IElseIfBlockContext); ok {
			tst[i] = t.(IElseIfBlockContext)
			i++
		}
	}

	return tst
}

func (s *IfStatementContext) ElseIfBlock(i int) IElseIfBlockContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElseIfBlockContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElseIfBlockContext)
}

func (s *IfStatementContext) ElseBlock() IElseBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElseBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElseBlockContext)
}

func (s *IfStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IfStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IfStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.EnterIfStatement(s)
	}
}

func (s *IfStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.ExitIfStatement(s)
	}
}

func (s *IfStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ServerScriptParserVisitor:
		return t.VisitIfStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ServerScriptParser) IfStatement() (localctx IIfStatementContext) {
	localctx = NewIfStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, ServerScriptParserRULE_ifStatement)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(344)
		p.IfBlock()
	}
	p.SetState(348)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 24, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(345)
				p.ElseIfBlock()
			}

		}
		p.SetState(350)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 24, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(352)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 25, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(351)
			p.ElseBlock()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIfBlockContext is an interface to support dynamic dispatch.
type IIfBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	If() antlr.TerminalNode
	OpenParen() antlr.TerminalNode
	ExpressionSequence() IExpressionSequenceContext
	CloseParen() antlr.TerminalNode
	Statement() IStatementContext

	// IsIfBlockContext differentiates from other interfaces.
	IsIfBlockContext()
}

type IfBlockContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIfBlockContext() *IfBlockContext {
	var p = new(IfBlockContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_ifBlock
	return p
}

func InitEmptyIfBlockContext(p *IfBlockContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_ifBlock
}

func (*IfBlockContext) IsIfBlockContext() {}

func NewIfBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IfBlockContext {
	var p = new(IfBlockContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ServerScriptParserRULE_ifBlock

	return p
}

func (s *IfBlockContext) GetParser() antlr.Parser { return s.parser }

func (s *IfBlockContext) If() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserIf, 0)
}

func (s *IfBlockContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserOpenParen, 0)
}

func (s *IfBlockContext) ExpressionSequence() IExpressionSequenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionSequenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionSequenceContext)
}

func (s *IfBlockContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserCloseParen, 0)
}

func (s *IfBlockContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *IfBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IfBlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IfBlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.EnterIfBlock(s)
	}
}

func (s *IfBlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.ExitIfBlock(s)
	}
}

func (s *IfBlockContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ServerScriptParserVisitor:
		return t.VisitIfBlock(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ServerScriptParser) IfBlock() (localctx IIfBlockContext) {
	localctx = NewIfBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, ServerScriptParserRULE_ifBlock)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(354)
		p.Match(ServerScriptParserIf)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(355)
		p.Match(ServerScriptParserOpenParen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(356)
		p.ExpressionSequence()
	}
	{
		p.SetState(357)
		p.Match(ServerScriptParserCloseParen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(358)
		p.Statement()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IElseIfBlockContext is an interface to support dynamic dispatch.
type IElseIfBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Else() antlr.TerminalNode
	If() antlr.TerminalNode
	OpenParen() antlr.TerminalNode
	ExpressionSequence() IExpressionSequenceContext
	CloseParen() antlr.TerminalNode
	Statement() IStatementContext

	// IsElseIfBlockContext differentiates from other interfaces.
	IsElseIfBlockContext()
}

type ElseIfBlockContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElseIfBlockContext() *ElseIfBlockContext {
	var p = new(ElseIfBlockContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_elseIfBlock
	return p
}

func InitEmptyElseIfBlockContext(p *ElseIfBlockContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_elseIfBlock
}

func (*ElseIfBlockContext) IsElseIfBlockContext() {}

func NewElseIfBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElseIfBlockContext {
	var p = new(ElseIfBlockContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ServerScriptParserRULE_elseIfBlock

	return p
}

func (s *ElseIfBlockContext) GetParser() antlr.Parser { return s.parser }

func (s *ElseIfBlockContext) Else() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserElse, 0)
}

func (s *ElseIfBlockContext) If() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserIf, 0)
}

func (s *ElseIfBlockContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserOpenParen, 0)
}

func (s *ElseIfBlockContext) ExpressionSequence() IExpressionSequenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionSequenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionSequenceContext)
}

func (s *ElseIfBlockContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserCloseParen, 0)
}

func (s *ElseIfBlockContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *ElseIfBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElseIfBlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ElseIfBlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.EnterElseIfBlock(s)
	}
}

func (s *ElseIfBlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.ExitElseIfBlock(s)
	}
}

func (s *ElseIfBlockContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ServerScriptParserVisitor:
		return t.VisitElseIfBlock(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ServerScriptParser) ElseIfBlock() (localctx IElseIfBlockContext) {
	localctx = NewElseIfBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, ServerScriptParserRULE_elseIfBlock)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(360)
		p.Match(ServerScriptParserElse)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(361)
		p.Match(ServerScriptParserIf)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(362)
		p.Match(ServerScriptParserOpenParen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(363)
		p.ExpressionSequence()
	}
	{
		p.SetState(364)
		p.Match(ServerScriptParserCloseParen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(365)
		p.Statement()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IElseBlockContext is an interface to support dynamic dispatch.
type IElseBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Else() antlr.TerminalNode
	Statement() IStatementContext

	// IsElseBlockContext differentiates from other interfaces.
	IsElseBlockContext()
}

type ElseBlockContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElseBlockContext() *ElseBlockContext {
	var p = new(ElseBlockContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_elseBlock
	return p
}

func InitEmptyElseBlockContext(p *ElseBlockContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_elseBlock
}

func (*ElseBlockContext) IsElseBlockContext() {}

func NewElseBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElseBlockContext {
	var p = new(ElseBlockContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ServerScriptParserRULE_elseBlock

	return p
}

func (s *ElseBlockContext) GetParser() antlr.Parser { return s.parser }

func (s *ElseBlockContext) Else() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserElse, 0)
}

func (s *ElseBlockContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *ElseBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElseBlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ElseBlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.EnterElseBlock(s)
	}
}

func (s *ElseBlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.ExitElseBlock(s)
	}
}

func (s *ElseBlockContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ServerScriptParserVisitor:
		return t.VisitElseBlock(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ServerScriptParser) ElseBlock() (localctx IElseBlockContext) {
	localctx = NewElseBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, ServerScriptParserRULE_elseBlock)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(367)
		p.Match(ServerScriptParserElse)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(368)
		p.Statement()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIterationStatementContext is an interface to support dynamic dispatch.
type IIterationStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsIterationStatementContext differentiates from other interfaces.
	IsIterationStatementContext()
}

type IterationStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIterationStatementContext() *IterationStatementContext {
	var p = new(IterationStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_iterationStatement
	return p
}

func InitEmptyIterationStatementContext(p *IterationStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_iterationStatement
}

func (*IterationStatementContext) IsIterationStatementContext() {}

func NewIterationStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IterationStatementContext {
	var p = new(IterationStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ServerScriptParserRULE_iterationStatement

	return p
}

func (s *IterationStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *IterationStatementContext) CopyAll(ctx *IterationStatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *IterationStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IterationStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type DoStatementContext struct {
	IterationStatementContext
}

func NewDoStatementContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DoStatementContext {
	var p = new(DoStatementContext)

	InitEmptyIterationStatementContext(&p.IterationStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*IterationStatementContext))

	return p
}

func (s *DoStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DoStatementContext) Do() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserDo, 0)
}

func (s *DoStatementContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *DoStatementContext) While() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserWhile, 0)
}

func (s *DoStatementContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserOpenParen, 0)
}

func (s *DoStatementContext) ExpressionSequence() IExpressionSequenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionSequenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionSequenceContext)
}

func (s *DoStatementContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserCloseParen, 0)
}

func (s *DoStatementContext) Eos() IEosContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEosContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *DoStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.EnterDoStatement(s)
	}
}

func (s *DoStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.ExitDoStatement(s)
	}
}

func (s *DoStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ServerScriptParserVisitor:
		return t.VisitDoStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

type WhileStatementContext struct {
	IterationStatementContext
}

func NewWhileStatementContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *WhileStatementContext {
	var p = new(WhileStatementContext)

	InitEmptyIterationStatementContext(&p.IterationStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*IterationStatementContext))

	return p
}

func (s *WhileStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhileStatementContext) While() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserWhile, 0)
}

func (s *WhileStatementContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserOpenParen, 0)
}

func (s *WhileStatementContext) ExpressionSequence() IExpressionSequenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionSequenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionSequenceContext)
}

func (s *WhileStatementContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserCloseParen, 0)
}

func (s *WhileStatementContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *WhileStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.EnterWhileStatement(s)
	}
}

func (s *WhileStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.ExitWhileStatement(s)
	}
}

func (s *WhileStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ServerScriptParserVisitor:
		return t.VisitWhileStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

type ForStatementContext struct {
	IterationStatementContext
}

func NewForStatementContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ForStatementContext {
	var p = new(ForStatementContext)

	InitEmptyIterationStatementContext(&p.IterationStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*IterationStatementContext))

	return p
}

func (s *ForStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForStatementContext) For() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserFor, 0)
}

func (s *ForStatementContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserOpenParen, 0)
}

func (s *ForStatementContext) AllSemiColon() []antlr.TerminalNode {
	return s.GetTokens(ServerScriptParserSemiColon)
}

func (s *ForStatementContext) SemiColon(i int) antlr.TerminalNode {
	return s.GetToken(ServerScriptParserSemiColon, i)
}

func (s *ForStatementContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserCloseParen, 0)
}

func (s *ForStatementContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *ForStatementContext) ForStatement1() IForStatement1Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForStatement1Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForStatement1Context)
}

func (s *ForStatementContext) ForStatement2() IForStatement2Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForStatement2Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForStatement2Context)
}

func (s *ForStatementContext) ForStatement3() IForStatement3Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForStatement3Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForStatement3Context)
}

func (s *ForStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.EnterForStatement(s)
	}
}

func (s *ForStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.ExitForStatement(s)
	}
}

func (s *ForStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ServerScriptParserVisitor:
		return t.VisitForStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

type ForOfStatementContext struct {
	IterationStatementContext
}

func NewForOfStatementContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ForOfStatementContext {
	var p = new(ForOfStatementContext)

	InitEmptyIterationStatementContext(&p.IterationStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*IterationStatementContext))

	return p
}

func (s *ForOfStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForOfStatementContext) For() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserFor, 0)
}

func (s *ForOfStatementContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserOpenParen, 0)
}

func (s *ForOfStatementContext) VarModifier() IVarModifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVarModifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVarModifierContext)
}

func (s *ForOfStatementContext) Of() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserOf, 0)
}

func (s *ForOfStatementContext) ExpressionSequence() IExpressionSequenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionSequenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionSequenceContext)
}

func (s *ForOfStatementContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserCloseParen, 0)
}

func (s *ForOfStatementContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *ForOfStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ForOfStatementContext) OfArrayLiteral() IOfArrayLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOfArrayLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOfArrayLiteralContext)
}

func (s *ForOfStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.EnterForOfStatement(s)
	}
}

func (s *ForOfStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.ExitForOfStatement(s)
	}
}

func (s *ForOfStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ServerScriptParserVisitor:
		return t.VisitForOfStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ServerScriptParser) IterationStatement() (localctx IIterationStatementContext) {
	localctx = NewIterationStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, ServerScriptParserRULE_iterationStatement)
	var _la int

	p.SetState(411)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 30, p.GetParserRuleContext()) {
	case 1:
		localctx = NewDoStatementContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(370)
			p.Match(ServerScriptParserDo)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(371)
			p.Statement()
		}
		{
			p.SetState(372)
			p.Match(ServerScriptParserWhile)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(373)
			p.Match(ServerScriptParserOpenParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(374)
			p.ExpressionSequence()
		}
		{
			p.SetState(375)
			p.Match(ServerScriptParserCloseParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(376)
			p.Eos()
		}

	case 2:
		localctx = NewWhileStatementContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(378)
			p.Match(ServerScriptParserWhile)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(379)
			p.Match(ServerScriptParserOpenParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(380)
			p.ExpressionSequence()
		}
		{
			p.SetState(381)
			p.Match(ServerScriptParserCloseParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(382)
			p.Statement()
		}

	case 3:
		localctx = NewForStatementContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(384)
			p.Match(ServerScriptParserFor)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(385)
			p.Match(ServerScriptParserOpenParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(387)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-4611686018361326928) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&8076717270712455167) != 0) {
			{
				p.SetState(386)
				p.ForStatement1()
			}

		}
		{
			p.SetState(389)
			p.Match(ServerScriptParserSemiColon)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(391)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-4611686018361326928) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&8076646901967228927) != 0) {
			{
				p.SetState(390)
				p.ForStatement2()
			}

		}
		{
			p.SetState(393)
			p.Match(ServerScriptParserSemiColon)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(395)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-4611686018361326928) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&8076646901967228927) != 0) {
			{
				p.SetState(394)
				p.ForStatement3()
			}

		}
		{
			p.SetState(397)
			p.Match(ServerScriptParserCloseParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(398)
			p.Statement()
		}

	case 4:
		localctx = NewForOfStatementContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(399)
			p.Match(ServerScriptParserFor)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(400)
			p.Match(ServerScriptParserOpenParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(401)
			p.VarModifier()
		}
		p.SetState(404)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case ServerScriptParserAs, ServerScriptParserFrom, ServerScriptParserOf, ServerScriptParserAsync, ServerScriptParserYield, ServerScriptParserIdentifier:
			{
				p.SetState(402)
				p.Identifier()
			}

		case ServerScriptParserOpenBracket:
			{
				p.SetState(403)
				p.OfArrayLiteral()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		{
			p.SetState(406)
			p.Match(ServerScriptParserOf)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(407)
			p.ExpressionSequence()
		}
		{
			p.SetState(408)
			p.Match(ServerScriptParserCloseParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(409)
			p.Statement()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOfArrayLiteralContext is an interface to support dynamic dispatch.
type IOfArrayLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OpenBracket() antlr.TerminalNode
	IdentifierList() IIdentifierListContext
	CloseBracket() antlr.TerminalNode

	// IsOfArrayLiteralContext differentiates from other interfaces.
	IsOfArrayLiteralContext()
}

type OfArrayLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOfArrayLiteralContext() *OfArrayLiteralContext {
	var p = new(OfArrayLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_ofArrayLiteral
	return p
}

func InitEmptyOfArrayLiteralContext(p *OfArrayLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_ofArrayLiteral
}

func (*OfArrayLiteralContext) IsOfArrayLiteralContext() {}

func NewOfArrayLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OfArrayLiteralContext {
	var p = new(OfArrayLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ServerScriptParserRULE_ofArrayLiteral

	return p
}

func (s *OfArrayLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *OfArrayLiteralContext) OpenBracket() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserOpenBracket, 0)
}

func (s *OfArrayLiteralContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *OfArrayLiteralContext) CloseBracket() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserCloseBracket, 0)
}

func (s *OfArrayLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OfArrayLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OfArrayLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.EnterOfArrayLiteral(s)
	}
}

func (s *OfArrayLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.ExitOfArrayLiteral(s)
	}
}

func (s *OfArrayLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ServerScriptParserVisitor:
		return t.VisitOfArrayLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ServerScriptParser) OfArrayLiteral() (localctx IOfArrayLiteralContext) {
	localctx = NewOfArrayLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, ServerScriptParserRULE_ofArrayLiteral)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(413)
		p.Match(ServerScriptParserOpenBracket)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(414)
		p.IdentifierList()
	}
	{
		p.SetState(415)
		p.Match(ServerScriptParserCloseBracket)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentifierListContext is an interface to support dynamic dispatch.
type IIdentifierListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllComma() []antlr.TerminalNode
	Comma(i int) antlr.TerminalNode
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext

	// IsIdentifierListContext differentiates from other interfaces.
	IsIdentifierListContext()
}

type IdentifierListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierListContext() *IdentifierListContext {
	var p = new(IdentifierListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_identifierList
	return p
}

func InitEmptyIdentifierListContext(p *IdentifierListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_identifierList
}

func (*IdentifierListContext) IsIdentifierListContext() {}

func NewIdentifierListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierListContext {
	var p = new(IdentifierListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ServerScriptParserRULE_identifierList

	return p
}

func (s *IdentifierListContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierListContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(ServerScriptParserComma)
}

func (s *IdentifierListContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(ServerScriptParserComma, i)
}

func (s *IdentifierListContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *IdentifierListContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *IdentifierListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.EnterIdentifierList(s)
	}
}

func (s *IdentifierListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.ExitIdentifierList(s)
	}
}

func (s *IdentifierListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ServerScriptParserVisitor:
		return t.VisitIdentifierList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ServerScriptParser) IdentifierList() (localctx IIdentifierListContext) {
	localctx = NewIdentifierListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, ServerScriptParserRULE_identifierList)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(420)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 31, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(417)
				p.Match(ServerScriptParserComma)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(422)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 31, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(424)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if (int64((_la-103)) & ^0x3f) == 0 && ((int64(1)<<(_la-103))&2106375) != 0 {
		{
			p.SetState(423)
			p.Identifier()
		}

	}
	p.SetState(434)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 34, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(427)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for ok := true; ok; ok = _la == ServerScriptParserComma {
				{
					p.SetState(426)
					p.Match(ServerScriptParserComma)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

				p.SetState(429)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(431)
				p.Identifier()
			}

		}
		p.SetState(436)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 34, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(440)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == ServerScriptParserComma {
		{
			p.SetState(437)
			p.Match(ServerScriptParserComma)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(442)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IForStatement1Context is an interface to support dynamic dispatch.
type IForStatement1Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ExpressionSequence() IExpressionSequenceContext
	VariableDeclarationList() IVariableDeclarationListContext

	// IsForStatement1Context differentiates from other interfaces.
	IsForStatement1Context()
}

type ForStatement1Context struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForStatement1Context() *ForStatement1Context {
	var p = new(ForStatement1Context)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_forStatement1
	return p
}

func InitEmptyForStatement1Context(p *ForStatement1Context) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_forStatement1
}

func (*ForStatement1Context) IsForStatement1Context() {}

func NewForStatement1Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForStatement1Context {
	var p = new(ForStatement1Context)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ServerScriptParserRULE_forStatement1

	return p
}

func (s *ForStatement1Context) GetParser() antlr.Parser { return s.parser }

func (s *ForStatement1Context) ExpressionSequence() IExpressionSequenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionSequenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionSequenceContext)
}

func (s *ForStatement1Context) VariableDeclarationList() IVariableDeclarationListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableDeclarationListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableDeclarationListContext)
}

func (s *ForStatement1Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForStatement1Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForStatement1Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.EnterForStatement1(s)
	}
}

func (s *ForStatement1Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.ExitForStatement1(s)
	}
}

func (s *ForStatement1Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ServerScriptParserVisitor:
		return t.VisitForStatement1(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ServerScriptParser) ForStatement1() (localctx IForStatement1Context) {
	localctx = NewForStatement1Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, ServerScriptParserRULE_forStatement1)
	p.SetState(445)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ServerScriptParserRegularExpressionLiteral, ServerScriptParserOpenBracket, ServerScriptParserOpenParen, ServerScriptParserOpenBrace, ServerScriptParserPlusPlus, ServerScriptParserMinusMinus, ServerScriptParserPlus, ServerScriptParserMinus, ServerScriptParserBitNot, ServerScriptParserNot, ServerScriptParserNullLiteral, ServerScriptParserNaNLiteral, ServerScriptParserUndefinedLiteral, ServerScriptParserBooleanLiteral, ServerScriptParserInfinityLiteral, ServerScriptParserDecimalLiteral, ServerScriptParserExponentLiteral, ServerScriptParserHexIntegerLiteral, ServerScriptParserOctalIntegerLiteral, ServerScriptParserBinaryIntegerLiteral, ServerScriptParserBigHexIntegerLiteral, ServerScriptParserBigOctalIntegerLiteral, ServerScriptParserBigBinaryIntegerLiteral, ServerScriptParserBigDecimalIntegerLiteral, ServerScriptParserNew, ServerScriptParserFunction_, ServerScriptParserThis, ServerScriptParserDelete, ServerScriptParserAs, ServerScriptParserFrom, ServerScriptParserOf, ServerScriptParserAsync, ServerScriptParserSync, ServerScriptParserYield, ServerScriptParserIdentifier, ServerScriptParserStringLiteral, ServerScriptParserBackTick:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(443)
			p.ExpressionSequence()
		}

	case ServerScriptParserLet, ServerScriptParserConst:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(444)
			p.VariableDeclarationList()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IForStatement2Context is an interface to support dynamic dispatch.
type IForStatement2Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ExpressionSequence() IExpressionSequenceContext

	// IsForStatement2Context differentiates from other interfaces.
	IsForStatement2Context()
}

type ForStatement2Context struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForStatement2Context() *ForStatement2Context {
	var p = new(ForStatement2Context)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_forStatement2
	return p
}

func InitEmptyForStatement2Context(p *ForStatement2Context) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_forStatement2
}

func (*ForStatement2Context) IsForStatement2Context() {}

func NewForStatement2Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForStatement2Context {
	var p = new(ForStatement2Context)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ServerScriptParserRULE_forStatement2

	return p
}

func (s *ForStatement2Context) GetParser() antlr.Parser { return s.parser }

func (s *ForStatement2Context) ExpressionSequence() IExpressionSequenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionSequenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionSequenceContext)
}

func (s *ForStatement2Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForStatement2Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForStatement2Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.EnterForStatement2(s)
	}
}

func (s *ForStatement2Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.ExitForStatement2(s)
	}
}

func (s *ForStatement2Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ServerScriptParserVisitor:
		return t.VisitForStatement2(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ServerScriptParser) ForStatement2() (localctx IForStatement2Context) {
	localctx = NewForStatement2Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, ServerScriptParserRULE_forStatement2)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(447)
		p.ExpressionSequence()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IForStatement3Context is an interface to support dynamic dispatch.
type IForStatement3Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ExpressionSequence() IExpressionSequenceContext

	// IsForStatement3Context differentiates from other interfaces.
	IsForStatement3Context()
}

type ForStatement3Context struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForStatement3Context() *ForStatement3Context {
	var p = new(ForStatement3Context)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_forStatement3
	return p
}

func InitEmptyForStatement3Context(p *ForStatement3Context) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_forStatement3
}

func (*ForStatement3Context) IsForStatement3Context() {}

func NewForStatement3Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForStatement3Context {
	var p = new(ForStatement3Context)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ServerScriptParserRULE_forStatement3

	return p
}

func (s *ForStatement3Context) GetParser() antlr.Parser { return s.parser }

func (s *ForStatement3Context) ExpressionSequence() IExpressionSequenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionSequenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionSequenceContext)
}

func (s *ForStatement3Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForStatement3Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForStatement3Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.EnterForStatement3(s)
	}
}

func (s *ForStatement3Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.ExitForStatement3(s)
	}
}

func (s *ForStatement3Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ServerScriptParserVisitor:
		return t.VisitForStatement3(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ServerScriptParser) ForStatement3() (localctx IForStatement3Context) {
	localctx = NewForStatement3Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, ServerScriptParserRULE_forStatement3)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(449)
		p.ExpressionSequence()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVarModifierContext is an interface to support dynamic dispatch.
type IVarModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Let() antlr.TerminalNode
	Const() antlr.TerminalNode

	// IsVarModifierContext differentiates from other interfaces.
	IsVarModifierContext()
}

type VarModifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVarModifierContext() *VarModifierContext {
	var p = new(VarModifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_varModifier
	return p
}

func InitEmptyVarModifierContext(p *VarModifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_varModifier
}

func (*VarModifierContext) IsVarModifierContext() {}

func NewVarModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VarModifierContext {
	var p = new(VarModifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ServerScriptParserRULE_varModifier

	return p
}

func (s *VarModifierContext) GetParser() antlr.Parser { return s.parser }

func (s *VarModifierContext) Let() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserLet, 0)
}

func (s *VarModifierContext) Const() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserConst, 0)
}

func (s *VarModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VarModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VarModifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.EnterVarModifier(s)
	}
}

func (s *VarModifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.ExitVarModifier(s)
	}
}

func (s *VarModifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ServerScriptParserVisitor:
		return t.VisitVarModifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ServerScriptParser) VarModifier() (localctx IVarModifierContext) {
	localctx = NewVarModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, ServerScriptParserRULE_varModifier)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(451)
		_la = p.GetTokenStream().LA(1)

		if !(_la == ServerScriptParserLet || _la == ServerScriptParserConst) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IContinueStatementContext is an interface to support dynamic dispatch.
type IContinueStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Continue() antlr.TerminalNode
	Eos() IEosContext
	Identifier() IIdentifierContext

	// IsContinueStatementContext differentiates from other interfaces.
	IsContinueStatementContext()
}

type ContinueStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyContinueStatementContext() *ContinueStatementContext {
	var p = new(ContinueStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_continueStatement
	return p
}

func InitEmptyContinueStatementContext(p *ContinueStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_continueStatement
}

func (*ContinueStatementContext) IsContinueStatementContext() {}

func NewContinueStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ContinueStatementContext {
	var p = new(ContinueStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ServerScriptParserRULE_continueStatement

	return p
}

func (s *ContinueStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ContinueStatementContext) Continue() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserContinue, 0)
}

func (s *ContinueStatementContext) Eos() IEosContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEosContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *ContinueStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ContinueStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ContinueStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ContinueStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.EnterContinueStatement(s)
	}
}

func (s *ContinueStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.ExitContinueStatement(s)
	}
}

func (s *ContinueStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ServerScriptParserVisitor:
		return t.VisitContinueStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ServerScriptParser) ContinueStatement() (localctx IContinueStatementContext) {
	localctx = NewContinueStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, ServerScriptParserRULE_continueStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(453)
		p.Match(ServerScriptParserContinue)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(456)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 37, p.GetParserRuleContext()) == 1 {
		p.SetState(454)

		if !(p.notLineTerminator()) {
			p.SetError(antlr.NewFailedPredicateException(p, "p.notLineTerminator()", ""))
			goto errorExit
		}
		{
			p.SetState(455)
			p.Identifier()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(458)
		p.Eos()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBreakStatementContext is an interface to support dynamic dispatch.
type IBreakStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Break() antlr.TerminalNode
	Eos() IEosContext
	Identifier() IIdentifierContext

	// IsBreakStatementContext differentiates from other interfaces.
	IsBreakStatementContext()
}

type BreakStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBreakStatementContext() *BreakStatementContext {
	var p = new(BreakStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_breakStatement
	return p
}

func InitEmptyBreakStatementContext(p *BreakStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_breakStatement
}

func (*BreakStatementContext) IsBreakStatementContext() {}

func NewBreakStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BreakStatementContext {
	var p = new(BreakStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ServerScriptParserRULE_breakStatement

	return p
}

func (s *BreakStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *BreakStatementContext) Break() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserBreak, 0)
}

func (s *BreakStatementContext) Eos() IEosContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEosContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *BreakStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *BreakStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BreakStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BreakStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.EnterBreakStatement(s)
	}
}

func (s *BreakStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.ExitBreakStatement(s)
	}
}

func (s *BreakStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ServerScriptParserVisitor:
		return t.VisitBreakStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ServerScriptParser) BreakStatement() (localctx IBreakStatementContext) {
	localctx = NewBreakStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, ServerScriptParserRULE_breakStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(460)
		p.Match(ServerScriptParserBreak)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(463)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 38, p.GetParserRuleContext()) == 1 {
		p.SetState(461)

		if !(p.notLineTerminator()) {
			p.SetError(antlr.NewFailedPredicateException(p, "p.notLineTerminator()", ""))
			goto errorExit
		}
		{
			p.SetState(462)
			p.Identifier()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(465)
		p.Eos()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReturnStatementContext is an interface to support dynamic dispatch.
type IReturnStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Return() antlr.TerminalNode
	Eos() IEosContext
	ExpressionSequence() IExpressionSequenceContext

	// IsReturnStatementContext differentiates from other interfaces.
	IsReturnStatementContext()
}

type ReturnStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReturnStatementContext() *ReturnStatementContext {
	var p = new(ReturnStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_returnStatement
	return p
}

func InitEmptyReturnStatementContext(p *ReturnStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_returnStatement
}

func (*ReturnStatementContext) IsReturnStatementContext() {}

func NewReturnStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReturnStatementContext {
	var p = new(ReturnStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ServerScriptParserRULE_returnStatement

	return p
}

func (s *ReturnStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ReturnStatementContext) Return() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserReturn, 0)
}

func (s *ReturnStatementContext) Eos() IEosContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEosContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *ReturnStatementContext) ExpressionSequence() IExpressionSequenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionSequenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionSequenceContext)
}

func (s *ReturnStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReturnStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReturnStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.EnterReturnStatement(s)
	}
}

func (s *ReturnStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.ExitReturnStatement(s)
	}
}

func (s *ReturnStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ServerScriptParserVisitor:
		return t.VisitReturnStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ServerScriptParser) ReturnStatement() (localctx IReturnStatementContext) {
	localctx = NewReturnStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, ServerScriptParserRULE_returnStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(467)
		p.Match(ServerScriptParserReturn)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(470)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 39, p.GetParserRuleContext()) == 1 {
		p.SetState(468)

		if !(p.notLineTerminator()) {
			p.SetError(antlr.NewFailedPredicateException(p, "p.notLineTerminator()", ""))
			goto errorExit
		}
		{
			p.SetState(469)
			p.ExpressionSequence()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(472)
		p.Eos()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISwitchStatementContext is an interface to support dynamic dispatch.
type ISwitchStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Switch() antlr.TerminalNode
	OpenParen() antlr.TerminalNode
	ExpressionSequence() IExpressionSequenceContext
	CloseParen() antlr.TerminalNode
	CaseBlock() ICaseBlockContext

	// IsSwitchStatementContext differentiates from other interfaces.
	IsSwitchStatementContext()
}

type SwitchStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySwitchStatementContext() *SwitchStatementContext {
	var p = new(SwitchStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_switchStatement
	return p
}

func InitEmptySwitchStatementContext(p *SwitchStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_switchStatement
}

func (*SwitchStatementContext) IsSwitchStatementContext() {}

func NewSwitchStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SwitchStatementContext {
	var p = new(SwitchStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ServerScriptParserRULE_switchStatement

	return p
}

func (s *SwitchStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SwitchStatementContext) Switch() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserSwitch, 0)
}

func (s *SwitchStatementContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserOpenParen, 0)
}

func (s *SwitchStatementContext) ExpressionSequence() IExpressionSequenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionSequenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionSequenceContext)
}

func (s *SwitchStatementContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserCloseParen, 0)
}

func (s *SwitchStatementContext) CaseBlock() ICaseBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICaseBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICaseBlockContext)
}

func (s *SwitchStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SwitchStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SwitchStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.EnterSwitchStatement(s)
	}
}

func (s *SwitchStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.ExitSwitchStatement(s)
	}
}

func (s *SwitchStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ServerScriptParserVisitor:
		return t.VisitSwitchStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ServerScriptParser) SwitchStatement() (localctx ISwitchStatementContext) {
	localctx = NewSwitchStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, ServerScriptParserRULE_switchStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(474)
		p.Match(ServerScriptParserSwitch)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(475)
		p.Match(ServerScriptParserOpenParen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(476)
		p.ExpressionSequence()
	}
	{
		p.SetState(477)
		p.Match(ServerScriptParserCloseParen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(478)
		p.CaseBlock()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICaseBlockContext is an interface to support dynamic dispatch.
type ICaseBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OpenBrace() antlr.TerminalNode
	CloseBrace() antlr.TerminalNode
	AllCaseClauses() []ICaseClausesContext
	CaseClauses(i int) ICaseClausesContext
	DefaultClause() IDefaultClauseContext

	// IsCaseBlockContext differentiates from other interfaces.
	IsCaseBlockContext()
}

type CaseBlockContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCaseBlockContext() *CaseBlockContext {
	var p = new(CaseBlockContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_caseBlock
	return p
}

func InitEmptyCaseBlockContext(p *CaseBlockContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_caseBlock
}

func (*CaseBlockContext) IsCaseBlockContext() {}

func NewCaseBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CaseBlockContext {
	var p = new(CaseBlockContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ServerScriptParserRULE_caseBlock

	return p
}

func (s *CaseBlockContext) GetParser() antlr.Parser { return s.parser }

func (s *CaseBlockContext) OpenBrace() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserOpenBrace, 0)
}

func (s *CaseBlockContext) CloseBrace() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserCloseBrace, 0)
}

func (s *CaseBlockContext) AllCaseClauses() []ICaseClausesContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICaseClausesContext); ok {
			len++
		}
	}

	tst := make([]ICaseClausesContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICaseClausesContext); ok {
			tst[i] = t.(ICaseClausesContext)
			i++
		}
	}

	return tst
}

func (s *CaseBlockContext) CaseClauses(i int) ICaseClausesContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICaseClausesContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICaseClausesContext)
}

func (s *CaseBlockContext) DefaultClause() IDefaultClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefaultClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefaultClauseContext)
}

func (s *CaseBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CaseBlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CaseBlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.EnterCaseBlock(s)
	}
}

func (s *CaseBlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.ExitCaseBlock(s)
	}
}

func (s *CaseBlockContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ServerScriptParserVisitor:
		return t.VisitCaseBlock(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ServerScriptParser) CaseBlock() (localctx ICaseBlockContext) {
	localctx = NewCaseBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, ServerScriptParserRULE_caseBlock)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(480)
		p.Match(ServerScriptParserOpenBrace)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(482)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ServerScriptParserCase {
		{
			p.SetState(481)
			p.CaseClauses()
		}

	}
	p.SetState(488)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ServerScriptParserDefault {
		{
			p.SetState(484)
			p.DefaultClause()
		}
		p.SetState(486)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ServerScriptParserCase {
			{
				p.SetState(485)
				p.CaseClauses()
			}

		}

	}
	{
		p.SetState(490)
		p.Match(ServerScriptParserCloseBrace)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICaseClausesContext is an interface to support dynamic dispatch.
type ICaseClausesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllCaseClause() []ICaseClauseContext
	CaseClause(i int) ICaseClauseContext

	// IsCaseClausesContext differentiates from other interfaces.
	IsCaseClausesContext()
}

type CaseClausesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCaseClausesContext() *CaseClausesContext {
	var p = new(CaseClausesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_caseClauses
	return p
}

func InitEmptyCaseClausesContext(p *CaseClausesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_caseClauses
}

func (*CaseClausesContext) IsCaseClausesContext() {}

func NewCaseClausesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CaseClausesContext {
	var p = new(CaseClausesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ServerScriptParserRULE_caseClauses

	return p
}

func (s *CaseClausesContext) GetParser() antlr.Parser { return s.parser }

func (s *CaseClausesContext) AllCaseClause() []ICaseClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICaseClauseContext); ok {
			len++
		}
	}

	tst := make([]ICaseClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICaseClauseContext); ok {
			tst[i] = t.(ICaseClauseContext)
			i++
		}
	}

	return tst
}

func (s *CaseClausesContext) CaseClause(i int) ICaseClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICaseClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICaseClauseContext)
}

func (s *CaseClausesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CaseClausesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CaseClausesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.EnterCaseClauses(s)
	}
}

func (s *CaseClausesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.ExitCaseClauses(s)
	}
}

func (s *CaseClausesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ServerScriptParserVisitor:
		return t.VisitCaseClauses(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ServerScriptParser) CaseClauses() (localctx ICaseClausesContext) {
	localctx = NewCaseClausesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, ServerScriptParserRULE_caseClauses)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(493)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == ServerScriptParserCase {
		{
			p.SetState(492)
			p.CaseClause()
		}

		p.SetState(495)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICaseClauseContext is an interface to support dynamic dispatch.
type ICaseClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Case() antlr.TerminalNode
	ExpressionSequence() IExpressionSequenceContext
	Colon() antlr.TerminalNode
	StatementList() IStatementListContext

	// IsCaseClauseContext differentiates from other interfaces.
	IsCaseClauseContext()
}

type CaseClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCaseClauseContext() *CaseClauseContext {
	var p = new(CaseClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_caseClause
	return p
}

func InitEmptyCaseClauseContext(p *CaseClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_caseClause
}

func (*CaseClauseContext) IsCaseClauseContext() {}

func NewCaseClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CaseClauseContext {
	var p = new(CaseClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ServerScriptParserRULE_caseClause

	return p
}

func (s *CaseClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *CaseClauseContext) Case() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserCase, 0)
}

func (s *CaseClauseContext) ExpressionSequence() IExpressionSequenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionSequenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionSequenceContext)
}

func (s *CaseClauseContext) Colon() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserColon, 0)
}

func (s *CaseClauseContext) StatementList() IStatementListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementListContext)
}

func (s *CaseClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CaseClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CaseClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.EnterCaseClause(s)
	}
}

func (s *CaseClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.ExitCaseClause(s)
	}
}

func (s *CaseClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ServerScriptParserVisitor:
		return t.VisitCaseClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ServerScriptParser) CaseClause() (localctx ICaseClauseContext) {
	localctx = NewCaseClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, ServerScriptParserRULE_caseClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(497)
		p.Match(ServerScriptParserCase)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(498)
		p.ExpressionSequence()
	}
	{
		p.SetState(499)
		p.Match(ServerScriptParserColon)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(501)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 44, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(500)
			p.StatementList()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDefaultClauseContext is an interface to support dynamic dispatch.
type IDefaultClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Default() antlr.TerminalNode
	Colon() antlr.TerminalNode
	StatementList() IStatementListContext

	// IsDefaultClauseContext differentiates from other interfaces.
	IsDefaultClauseContext()
}

type DefaultClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDefaultClauseContext() *DefaultClauseContext {
	var p = new(DefaultClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_defaultClause
	return p
}

func InitEmptyDefaultClauseContext(p *DefaultClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_defaultClause
}

func (*DefaultClauseContext) IsDefaultClauseContext() {}

func NewDefaultClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DefaultClauseContext {
	var p = new(DefaultClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ServerScriptParserRULE_defaultClause

	return p
}

func (s *DefaultClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DefaultClauseContext) Default() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserDefault, 0)
}

func (s *DefaultClauseContext) Colon() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserColon, 0)
}

func (s *DefaultClauseContext) StatementList() IStatementListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementListContext)
}

func (s *DefaultClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefaultClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DefaultClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.EnterDefaultClause(s)
	}
}

func (s *DefaultClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.ExitDefaultClause(s)
	}
}

func (s *DefaultClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ServerScriptParserVisitor:
		return t.VisitDefaultClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ServerScriptParser) DefaultClause() (localctx IDefaultClauseContext) {
	localctx = NewDefaultClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, ServerScriptParserRULE_defaultClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(503)
		p.Match(ServerScriptParserDefault)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(504)
		p.Match(ServerScriptParserColon)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(506)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 45, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(505)
			p.StatementList()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IThrowStatementContext is an interface to support dynamic dispatch.
type IThrowStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Throw() antlr.TerminalNode
	ExpressionSequence() IExpressionSequenceContext
	Eos() IEosContext

	// IsThrowStatementContext differentiates from other interfaces.
	IsThrowStatementContext()
}

type ThrowStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyThrowStatementContext() *ThrowStatementContext {
	var p = new(ThrowStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_throwStatement
	return p
}

func InitEmptyThrowStatementContext(p *ThrowStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_throwStatement
}

func (*ThrowStatementContext) IsThrowStatementContext() {}

func NewThrowStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ThrowStatementContext {
	var p = new(ThrowStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ServerScriptParserRULE_throwStatement

	return p
}

func (s *ThrowStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ThrowStatementContext) Throw() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserThrow, 0)
}

func (s *ThrowStatementContext) ExpressionSequence() IExpressionSequenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionSequenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionSequenceContext)
}

func (s *ThrowStatementContext) Eos() IEosContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEosContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *ThrowStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ThrowStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ThrowStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.EnterThrowStatement(s)
	}
}

func (s *ThrowStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.ExitThrowStatement(s)
	}
}

func (s *ThrowStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ServerScriptParserVisitor:
		return t.VisitThrowStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ServerScriptParser) ThrowStatement() (localctx IThrowStatementContext) {
	localctx = NewThrowStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, ServerScriptParserRULE_throwStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(508)
		p.Match(ServerScriptParserThrow)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(509)

	if !(p.notLineTerminator()) {
		p.SetError(antlr.NewFailedPredicateException(p, "p.notLineTerminator()", ""))
		goto errorExit
	}
	{
		p.SetState(510)
		p.ExpressionSequence()
	}
	{
		p.SetState(511)
		p.Eos()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITryStatementContext is an interface to support dynamic dispatch.
type ITryStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Try() antlr.TerminalNode
	Block() IBlockContext
	CatchProduction() ICatchProductionContext
	FinallyProduction() IFinallyProductionContext

	// IsTryStatementContext differentiates from other interfaces.
	IsTryStatementContext()
}

type TryStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTryStatementContext() *TryStatementContext {
	var p = new(TryStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_tryStatement
	return p
}

func InitEmptyTryStatementContext(p *TryStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_tryStatement
}

func (*TryStatementContext) IsTryStatementContext() {}

func NewTryStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TryStatementContext {
	var p = new(TryStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ServerScriptParserRULE_tryStatement

	return p
}

func (s *TryStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *TryStatementContext) Try() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserTry, 0)
}

func (s *TryStatementContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *TryStatementContext) CatchProduction() ICatchProductionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICatchProductionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICatchProductionContext)
}

func (s *TryStatementContext) FinallyProduction() IFinallyProductionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFinallyProductionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFinallyProductionContext)
}

func (s *TryStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TryStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TryStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.EnterTryStatement(s)
	}
}

func (s *TryStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.ExitTryStatement(s)
	}
}

func (s *TryStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ServerScriptParserVisitor:
		return t.VisitTryStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ServerScriptParser) TryStatement() (localctx ITryStatementContext) {
	localctx = NewTryStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, ServerScriptParserRULE_tryStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(513)
		p.Match(ServerScriptParserTry)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(514)
		p.Block()
	}
	p.SetState(520)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ServerScriptParserCatch:
		{
			p.SetState(515)
			p.CatchProduction()
		}
		p.SetState(517)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 46, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(516)
				p.FinallyProduction()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case ServerScriptParserFinally:
		{
			p.SetState(519)
			p.FinallyProduction()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICatchProductionContext is an interface to support dynamic dispatch.
type ICatchProductionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Catch() antlr.TerminalNode
	Block() IBlockContext
	OpenParen() antlr.TerminalNode
	CloseParen() antlr.TerminalNode
	Assignable() IAssignableContext

	// IsCatchProductionContext differentiates from other interfaces.
	IsCatchProductionContext()
}

type CatchProductionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCatchProductionContext() *CatchProductionContext {
	var p = new(CatchProductionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_catchProduction
	return p
}

func InitEmptyCatchProductionContext(p *CatchProductionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_catchProduction
}

func (*CatchProductionContext) IsCatchProductionContext() {}

func NewCatchProductionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CatchProductionContext {
	var p = new(CatchProductionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ServerScriptParserRULE_catchProduction

	return p
}

func (s *CatchProductionContext) GetParser() antlr.Parser { return s.parser }

func (s *CatchProductionContext) Catch() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserCatch, 0)
}

func (s *CatchProductionContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *CatchProductionContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserOpenParen, 0)
}

func (s *CatchProductionContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserCloseParen, 0)
}

func (s *CatchProductionContext) Assignable() IAssignableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignableContext)
}

func (s *CatchProductionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CatchProductionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CatchProductionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.EnterCatchProduction(s)
	}
}

func (s *CatchProductionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.ExitCatchProduction(s)
	}
}

func (s *CatchProductionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ServerScriptParserVisitor:
		return t.VisitCatchProduction(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ServerScriptParser) CatchProduction() (localctx ICatchProductionContext) {
	localctx = NewCatchProductionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, ServerScriptParserRULE_catchProduction)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(522)
		p.Match(ServerScriptParserCatch)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(528)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ServerScriptParserOpenParen {
		{
			p.SetState(523)
			p.Match(ServerScriptParserOpenParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(525)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ServerScriptParserOpenBracket || _la == ServerScriptParserOpenBrace || ((int64((_la-103)) & ^0x3f) == 0 && ((int64(1)<<(_la-103))&2106375) != 0) {
			{
				p.SetState(524)
				p.Assignable()
			}

		}
		{
			p.SetState(527)
			p.Match(ServerScriptParserCloseParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(530)
		p.Block()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFinallyProductionContext is an interface to support dynamic dispatch.
type IFinallyProductionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Finally() antlr.TerminalNode
	Block() IBlockContext

	// IsFinallyProductionContext differentiates from other interfaces.
	IsFinallyProductionContext()
}

type FinallyProductionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFinallyProductionContext() *FinallyProductionContext {
	var p = new(FinallyProductionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_finallyProduction
	return p
}

func InitEmptyFinallyProductionContext(p *FinallyProductionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_finallyProduction
}

func (*FinallyProductionContext) IsFinallyProductionContext() {}

func NewFinallyProductionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FinallyProductionContext {
	var p = new(FinallyProductionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ServerScriptParserRULE_finallyProduction

	return p
}

func (s *FinallyProductionContext) GetParser() antlr.Parser { return s.parser }

func (s *FinallyProductionContext) Finally() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserFinally, 0)
}

func (s *FinallyProductionContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *FinallyProductionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FinallyProductionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FinallyProductionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.EnterFinallyProduction(s)
	}
}

func (s *FinallyProductionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.ExitFinallyProduction(s)
	}
}

func (s *FinallyProductionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ServerScriptParserVisitor:
		return t.VisitFinallyProduction(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ServerScriptParser) FinallyProduction() (localctx IFinallyProductionContext) {
	localctx = NewFinallyProductionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, ServerScriptParserRULE_finallyProduction)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(532)
		p.Match(ServerScriptParserFinally)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(533)
		p.Block()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionDeclarationContext is an interface to support dynamic dispatch.
type IFunctionDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Function_() antlr.TerminalNode
	Identifier() IIdentifierContext
	OpenParen() antlr.TerminalNode
	CloseParen() antlr.TerminalNode
	FunctionBody() IFunctionBodyContext
	FormalParameterList() IFormalParameterListContext

	// IsFunctionDeclarationContext differentiates from other interfaces.
	IsFunctionDeclarationContext()
}

type FunctionDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionDeclarationContext() *FunctionDeclarationContext {
	var p = new(FunctionDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_functionDeclaration
	return p
}

func InitEmptyFunctionDeclarationContext(p *FunctionDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_functionDeclaration
}

func (*FunctionDeclarationContext) IsFunctionDeclarationContext() {}

func NewFunctionDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionDeclarationContext {
	var p = new(FunctionDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ServerScriptParserRULE_functionDeclaration

	return p
}

func (s *FunctionDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionDeclarationContext) Function_() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserFunction_, 0)
}

func (s *FunctionDeclarationContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *FunctionDeclarationContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserOpenParen, 0)
}

func (s *FunctionDeclarationContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserCloseParen, 0)
}

func (s *FunctionDeclarationContext) FunctionBody() IFunctionBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionBodyContext)
}

func (s *FunctionDeclarationContext) FormalParameterList() IFormalParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFormalParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFormalParameterListContext)
}

func (s *FunctionDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.EnterFunctionDeclaration(s)
	}
}

func (s *FunctionDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.ExitFunctionDeclaration(s)
	}
}

func (s *FunctionDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ServerScriptParserVisitor:
		return t.VisitFunctionDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ServerScriptParser) FunctionDeclaration() (localctx IFunctionDeclarationContext) {
	localctx = NewFunctionDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, ServerScriptParserRULE_functionDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(535)
		p.Match(ServerScriptParserFunction_)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(536)
		p.Identifier()
	}
	{
		p.SetState(537)
		p.Match(ServerScriptParserOpenParen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(539)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&262688) != 0) || ((int64((_la-103)) & ^0x3f) == 0 && ((int64(1)<<(_la-103))&2106375) != 0) {
		{
			p.SetState(538)
			p.FormalParameterList()
		}

	}
	{
		p.SetState(541)
		p.Match(ServerScriptParserCloseParen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(542)
		p.FunctionBody()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFormalParameterListContext is an interface to support dynamic dispatch.
type IFormalParameterListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllFormalParameterArg() []IFormalParameterArgContext
	FormalParameterArg(i int) IFormalParameterArgContext
	AllComma() []antlr.TerminalNode
	Comma(i int) antlr.TerminalNode
	LastFormalParameterArg() ILastFormalParameterArgContext

	// IsFormalParameterListContext differentiates from other interfaces.
	IsFormalParameterListContext()
}

type FormalParameterListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFormalParameterListContext() *FormalParameterListContext {
	var p = new(FormalParameterListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_formalParameterList
	return p
}

func InitEmptyFormalParameterListContext(p *FormalParameterListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_formalParameterList
}

func (*FormalParameterListContext) IsFormalParameterListContext() {}

func NewFormalParameterListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FormalParameterListContext {
	var p = new(FormalParameterListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ServerScriptParserRULE_formalParameterList

	return p
}

func (s *FormalParameterListContext) GetParser() antlr.Parser { return s.parser }

func (s *FormalParameterListContext) AllFormalParameterArg() []IFormalParameterArgContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFormalParameterArgContext); ok {
			len++
		}
	}

	tst := make([]IFormalParameterArgContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFormalParameterArgContext); ok {
			tst[i] = t.(IFormalParameterArgContext)
			i++
		}
	}

	return tst
}

func (s *FormalParameterListContext) FormalParameterArg(i int) IFormalParameterArgContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFormalParameterArgContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFormalParameterArgContext)
}

func (s *FormalParameterListContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(ServerScriptParserComma)
}

func (s *FormalParameterListContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(ServerScriptParserComma, i)
}

func (s *FormalParameterListContext) LastFormalParameterArg() ILastFormalParameterArgContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILastFormalParameterArgContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILastFormalParameterArgContext)
}

func (s *FormalParameterListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FormalParameterListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FormalParameterListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.EnterFormalParameterList(s)
	}
}

func (s *FormalParameterListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.ExitFormalParameterList(s)
	}
}

func (s *FormalParameterListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ServerScriptParserVisitor:
		return t.VisitFormalParameterList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ServerScriptParser) FormalParameterList() (localctx IFormalParameterListContext) {
	localctx = NewFormalParameterListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, ServerScriptParserRULE_formalParameterList)
	var _la int

	var _alt int

	p.SetState(557)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ServerScriptParserOpenBracket, ServerScriptParserOpenBrace, ServerScriptParserAs, ServerScriptParserFrom, ServerScriptParserOf, ServerScriptParserAsync, ServerScriptParserYield, ServerScriptParserIdentifier:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(544)
			p.FormalParameterArg()
		}
		p.SetState(549)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 51, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(545)
					p.Match(ServerScriptParserComma)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(546)
					p.FormalParameterArg()
				}

			}
			p.SetState(551)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 51, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(554)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ServerScriptParserComma {
			{
				p.SetState(552)
				p.Match(ServerScriptParserComma)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(553)
				p.LastFormalParameterArg()
			}

		}

	case ServerScriptParserEllipsis:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(556)
			p.LastFormalParameterArg()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFormalParameterArgContext is an interface to support dynamic dispatch.
type IFormalParameterArgContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Assignable() IAssignableContext
	Assign() antlr.TerminalNode
	SingleExpression() ISingleExpressionContext

	// IsFormalParameterArgContext differentiates from other interfaces.
	IsFormalParameterArgContext()
}

type FormalParameterArgContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFormalParameterArgContext() *FormalParameterArgContext {
	var p = new(FormalParameterArgContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_formalParameterArg
	return p
}

func InitEmptyFormalParameterArgContext(p *FormalParameterArgContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_formalParameterArg
}

func (*FormalParameterArgContext) IsFormalParameterArgContext() {}

func NewFormalParameterArgContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FormalParameterArgContext {
	var p = new(FormalParameterArgContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ServerScriptParserRULE_formalParameterArg

	return p
}

func (s *FormalParameterArgContext) GetParser() antlr.Parser { return s.parser }

func (s *FormalParameterArgContext) Assignable() IAssignableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignableContext)
}

func (s *FormalParameterArgContext) Assign() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserAssign, 0)
}

func (s *FormalParameterArgContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *FormalParameterArgContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FormalParameterArgContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FormalParameterArgContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.EnterFormalParameterArg(s)
	}
}

func (s *FormalParameterArgContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.ExitFormalParameterArg(s)
	}
}

func (s *FormalParameterArgContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ServerScriptParserVisitor:
		return t.VisitFormalParameterArg(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ServerScriptParser) FormalParameterArg() (localctx IFormalParameterArgContext) {
	localctx = NewFormalParameterArgContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, ServerScriptParserRULE_formalParameterArg)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(559)
		p.Assignable()
	}
	p.SetState(562)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ServerScriptParserAssign {
		{
			p.SetState(560)
			p.Match(ServerScriptParserAssign)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(561)
			p.singleExpression(0)
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILastFormalParameterArgContext is an interface to support dynamic dispatch.
type ILastFormalParameterArgContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Ellipsis() antlr.TerminalNode
	SingleExpression() ISingleExpressionContext

	// IsLastFormalParameterArgContext differentiates from other interfaces.
	IsLastFormalParameterArgContext()
}

type LastFormalParameterArgContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLastFormalParameterArgContext() *LastFormalParameterArgContext {
	var p = new(LastFormalParameterArgContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_lastFormalParameterArg
	return p
}

func InitEmptyLastFormalParameterArgContext(p *LastFormalParameterArgContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_lastFormalParameterArg
}

func (*LastFormalParameterArgContext) IsLastFormalParameterArgContext() {}

func NewLastFormalParameterArgContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LastFormalParameterArgContext {
	var p = new(LastFormalParameterArgContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ServerScriptParserRULE_lastFormalParameterArg

	return p
}

func (s *LastFormalParameterArgContext) GetParser() antlr.Parser { return s.parser }

func (s *LastFormalParameterArgContext) Ellipsis() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserEllipsis, 0)
}

func (s *LastFormalParameterArgContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *LastFormalParameterArgContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LastFormalParameterArgContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LastFormalParameterArgContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.EnterLastFormalParameterArg(s)
	}
}

func (s *LastFormalParameterArgContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.ExitLastFormalParameterArg(s)
	}
}

func (s *LastFormalParameterArgContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ServerScriptParserVisitor:
		return t.VisitLastFormalParameterArg(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ServerScriptParser) LastFormalParameterArg() (localctx ILastFormalParameterArgContext) {
	localctx = NewLastFormalParameterArgContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, ServerScriptParserRULE_lastFormalParameterArg)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(564)
		p.Match(ServerScriptParserEllipsis)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(565)
		p.singleExpression(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionBodyContext is an interface to support dynamic dispatch.
type IFunctionBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OpenBrace() antlr.TerminalNode
	CloseBrace() antlr.TerminalNode
	SourceElements() ISourceElementsContext

	// IsFunctionBodyContext differentiates from other interfaces.
	IsFunctionBodyContext()
}

type FunctionBodyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionBodyContext() *FunctionBodyContext {
	var p = new(FunctionBodyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_functionBody
	return p
}

func InitEmptyFunctionBodyContext(p *FunctionBodyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_functionBody
}

func (*FunctionBodyContext) IsFunctionBodyContext() {}

func NewFunctionBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionBodyContext {
	var p = new(FunctionBodyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ServerScriptParserRULE_functionBody

	return p
}

func (s *FunctionBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionBodyContext) OpenBrace() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserOpenBrace, 0)
}

func (s *FunctionBodyContext) CloseBrace() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserCloseBrace, 0)
}

func (s *FunctionBodyContext) SourceElements() ISourceElementsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISourceElementsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISourceElementsContext)
}

func (s *FunctionBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.EnterFunctionBody(s)
	}
}

func (s *FunctionBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.ExitFunctionBody(s)
	}
}

func (s *FunctionBodyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ServerScriptParserVisitor:
		return t.VisitFunctionBody(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ServerScriptParser) FunctionBody() (localctx IFunctionBodyContext) {
	localctx = NewFunctionBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, ServerScriptParserRULE_functionBody)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(567)
		p.Match(ServerScriptParserOpenBrace)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(569)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 55, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(568)
			p.SourceElements()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(571)
		p.Match(ServerScriptParserCloseBrace)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IArrayLiteralContext is an interface to support dynamic dispatch.
type IArrayLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OpenBracket() antlr.TerminalNode
	ElementList() IElementListContext
	CloseBracket() antlr.TerminalNode

	// IsArrayLiteralContext differentiates from other interfaces.
	IsArrayLiteralContext()
}

type ArrayLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayLiteralContext() *ArrayLiteralContext {
	var p = new(ArrayLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_arrayLiteral
	return p
}

func InitEmptyArrayLiteralContext(p *ArrayLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_arrayLiteral
}

func (*ArrayLiteralContext) IsArrayLiteralContext() {}

func NewArrayLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayLiteralContext {
	var p = new(ArrayLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ServerScriptParserRULE_arrayLiteral

	return p
}

func (s *ArrayLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrayLiteralContext) OpenBracket() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserOpenBracket, 0)
}

func (s *ArrayLiteralContext) ElementList() IElementListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElementListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElementListContext)
}

func (s *ArrayLiteralContext) CloseBracket() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserCloseBracket, 0)
}

func (s *ArrayLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrayLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.EnterArrayLiteral(s)
	}
}

func (s *ArrayLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.ExitArrayLiteral(s)
	}
}

func (s *ArrayLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ServerScriptParserVisitor:
		return t.VisitArrayLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ServerScriptParser) ArrayLiteral() (localctx IArrayLiteralContext) {
	localctx = NewArrayLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, ServerScriptParserRULE_arrayLiteral)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(573)
		p.Match(ServerScriptParserOpenBracket)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(574)
		p.ElementList()
	}
	{
		p.SetState(575)
		p.Match(ServerScriptParserCloseBracket)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IElementListContext is an interface to support dynamic dispatch.
type IElementListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllComma() []antlr.TerminalNode
	Comma(i int) antlr.TerminalNode
	AllArrayElement() []IArrayElementContext
	ArrayElement(i int) IArrayElementContext

	// IsElementListContext differentiates from other interfaces.
	IsElementListContext()
}

type ElementListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElementListContext() *ElementListContext {
	var p = new(ElementListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_elementList
	return p
}

func InitEmptyElementListContext(p *ElementListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_elementList
}

func (*ElementListContext) IsElementListContext() {}

func NewElementListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElementListContext {
	var p = new(ElementListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ServerScriptParserRULE_elementList

	return p
}

func (s *ElementListContext) GetParser() antlr.Parser { return s.parser }

func (s *ElementListContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(ServerScriptParserComma)
}

func (s *ElementListContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(ServerScriptParserComma, i)
}

func (s *ElementListContext) AllArrayElement() []IArrayElementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IArrayElementContext); ok {
			len++
		}
	}

	tst := make([]IArrayElementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IArrayElementContext); ok {
			tst[i] = t.(IArrayElementContext)
			i++
		}
	}

	return tst
}

func (s *ElementListContext) ArrayElement(i int) IArrayElementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayElementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayElementContext)
}

func (s *ElementListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElementListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ElementListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.EnterElementList(s)
	}
}

func (s *ElementListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.ExitElementList(s)
	}
}

func (s *ElementListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ServerScriptParserVisitor:
		return t.VisitElementList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ServerScriptParser) ElementList() (localctx IElementListContext) {
	localctx = NewElementListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, ServerScriptParserRULE_elementList)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(580)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 56, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(577)
				p.Match(ServerScriptParserComma)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(582)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 56, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(584)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-4611686018361064784) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&8076646901967228927) != 0) {
		{
			p.SetState(583)
			p.ArrayElement()
		}

	}
	p.SetState(594)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 59, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(587)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for ok := true; ok; ok = _la == ServerScriptParserComma {
				{
					p.SetState(586)
					p.Match(ServerScriptParserComma)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

				p.SetState(589)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(591)
				p.ArrayElement()
			}

		}
		p.SetState(596)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 59, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(600)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == ServerScriptParserComma {
		{
			p.SetState(597)
			p.Match(ServerScriptParserComma)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(602)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IArrayElementContext is an interface to support dynamic dispatch.
type IArrayElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SingleExpression() ISingleExpressionContext
	Ellipsis() antlr.TerminalNode

	// IsArrayElementContext differentiates from other interfaces.
	IsArrayElementContext()
}

type ArrayElementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayElementContext() *ArrayElementContext {
	var p = new(ArrayElementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_arrayElement
	return p
}

func InitEmptyArrayElementContext(p *ArrayElementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_arrayElement
}

func (*ArrayElementContext) IsArrayElementContext() {}

func NewArrayElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayElementContext {
	var p = new(ArrayElementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ServerScriptParserRULE_arrayElement

	return p
}

func (s *ArrayElementContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrayElementContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *ArrayElementContext) Ellipsis() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserEllipsis, 0)
}

func (s *ArrayElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrayElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.EnterArrayElement(s)
	}
}

func (s *ArrayElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.ExitArrayElement(s)
	}
}

func (s *ArrayElementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ServerScriptParserVisitor:
		return t.VisitArrayElement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ServerScriptParser) ArrayElement() (localctx IArrayElementContext) {
	localctx = NewArrayElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, ServerScriptParserRULE_arrayElement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(604)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ServerScriptParserEllipsis {
		{
			p.SetState(603)
			p.Match(ServerScriptParserEllipsis)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(606)
		p.singleExpression(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPropertyAssignmentContext is an interface to support dynamic dispatch.
type IPropertyAssignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsPropertyAssignmentContext differentiates from other interfaces.
	IsPropertyAssignmentContext()
}

type PropertyAssignmentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertyAssignmentContext() *PropertyAssignmentContext {
	var p = new(PropertyAssignmentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_propertyAssignment
	return p
}

func InitEmptyPropertyAssignmentContext(p *PropertyAssignmentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_propertyAssignment
}

func (*PropertyAssignmentContext) IsPropertyAssignmentContext() {}

func NewPropertyAssignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyAssignmentContext {
	var p = new(PropertyAssignmentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ServerScriptParserRULE_propertyAssignment

	return p
}

func (s *PropertyAssignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyAssignmentContext) CopyAll(ctx *PropertyAssignmentContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *PropertyAssignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyAssignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type PropertyExpressionAssignmentContext struct {
	PropertyAssignmentContext
}

func NewPropertyExpressionAssignmentContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PropertyExpressionAssignmentContext {
	var p = new(PropertyExpressionAssignmentContext)

	InitEmptyPropertyAssignmentContext(&p.PropertyAssignmentContext)
	p.parser = parser
	p.CopyAll(ctx.(*PropertyAssignmentContext))

	return p
}

func (s *PropertyExpressionAssignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyExpressionAssignmentContext) PropertyName() IPropertyNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyNameContext)
}

func (s *PropertyExpressionAssignmentContext) Colon() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserColon, 0)
}

func (s *PropertyExpressionAssignmentContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *PropertyExpressionAssignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.EnterPropertyExpressionAssignment(s)
	}
}

func (s *PropertyExpressionAssignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.ExitPropertyExpressionAssignment(s)
	}
}

func (s *PropertyExpressionAssignmentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ServerScriptParserVisitor:
		return t.VisitPropertyExpressionAssignment(s)

	default:
		return t.VisitChildren(s)
	}
}

type ComputedPropertyExpressionAssignmentContext struct {
	PropertyAssignmentContext
}

func NewComputedPropertyExpressionAssignmentContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ComputedPropertyExpressionAssignmentContext {
	var p = new(ComputedPropertyExpressionAssignmentContext)

	InitEmptyPropertyAssignmentContext(&p.PropertyAssignmentContext)
	p.parser = parser
	p.CopyAll(ctx.(*PropertyAssignmentContext))

	return p
}

func (s *ComputedPropertyExpressionAssignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComputedPropertyExpressionAssignmentContext) OpenBracket() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserOpenBracket, 0)
}

func (s *ComputedPropertyExpressionAssignmentContext) AllSingleExpression() []ISingleExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			len++
		}
	}

	tst := make([]ISingleExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISingleExpressionContext); ok {
			tst[i] = t.(ISingleExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ComputedPropertyExpressionAssignmentContext) SingleExpression(i int) ISingleExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *ComputedPropertyExpressionAssignmentContext) CloseBracket() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserCloseBracket, 0)
}

func (s *ComputedPropertyExpressionAssignmentContext) Colon() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserColon, 0)
}

func (s *ComputedPropertyExpressionAssignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.EnterComputedPropertyExpressionAssignment(s)
	}
}

func (s *ComputedPropertyExpressionAssignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.ExitComputedPropertyExpressionAssignment(s)
	}
}

func (s *ComputedPropertyExpressionAssignmentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ServerScriptParserVisitor:
		return t.VisitComputedPropertyExpressionAssignment(s)

	default:
		return t.VisitChildren(s)
	}
}

type PropertyShorthandContext struct {
	PropertyAssignmentContext
}

func NewPropertyShorthandContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PropertyShorthandContext {
	var p = new(PropertyShorthandContext)

	InitEmptyPropertyAssignmentContext(&p.PropertyAssignmentContext)
	p.parser = parser
	p.CopyAll(ctx.(*PropertyAssignmentContext))

	return p
}

func (s *PropertyShorthandContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyShorthandContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *PropertyShorthandContext) Ellipsis() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserEllipsis, 0)
}

func (s *PropertyShorthandContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.EnterPropertyShorthand(s)
	}
}

func (s *PropertyShorthandContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.ExitPropertyShorthand(s)
	}
}

func (s *PropertyShorthandContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ServerScriptParserVisitor:
		return t.VisitPropertyShorthand(s)

	default:
		return t.VisitChildren(s)
	}
}

type FunctionPropertyContext struct {
	PropertyAssignmentContext
}

func NewFunctionPropertyContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *FunctionPropertyContext {
	var p = new(FunctionPropertyContext)

	InitEmptyPropertyAssignmentContext(&p.PropertyAssignmentContext)
	p.parser = parser
	p.CopyAll(ctx.(*PropertyAssignmentContext))

	return p
}

func (s *FunctionPropertyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionPropertyContext) PropertyName() IPropertyNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyNameContext)
}

func (s *FunctionPropertyContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserOpenParen, 0)
}

func (s *FunctionPropertyContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserCloseParen, 0)
}

func (s *FunctionPropertyContext) FunctionBody() IFunctionBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionBodyContext)
}

func (s *FunctionPropertyContext) Multiply() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserMultiply, 0)
}

func (s *FunctionPropertyContext) FormalParameterList() IFormalParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFormalParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFormalParameterListContext)
}

func (s *FunctionPropertyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.EnterFunctionProperty(s)
	}
}

func (s *FunctionPropertyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.ExitFunctionProperty(s)
	}
}

func (s *FunctionPropertyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ServerScriptParserVisitor:
		return t.VisitFunctionProperty(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ServerScriptParser) PropertyAssignment() (localctx IPropertyAssignmentContext) {
	localctx = NewPropertyAssignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, ServerScriptParserRULE_propertyAssignment)
	var _la int

	p.SetState(633)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 65, p.GetParserRuleContext()) {
	case 1:
		localctx = NewPropertyExpressionAssignmentContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(608)
			p.PropertyName()
		}
		{
			p.SetState(609)
			p.Match(ServerScriptParserColon)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(610)
			p.singleExpression(0)
		}

	case 2:
		localctx = NewComputedPropertyExpressionAssignmentContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(612)
			p.Match(ServerScriptParserOpenBracket)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(613)
			p.singleExpression(0)
		}
		{
			p.SetState(614)
			p.Match(ServerScriptParserCloseBracket)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(615)
			p.Match(ServerScriptParserColon)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(616)
			p.singleExpression(0)
		}

	case 3:
		localctx = NewFunctionPropertyContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		p.SetState(619)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ServerScriptParserMultiply {
			{
				p.SetState(618)
				p.Match(ServerScriptParserMultiply)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(621)
			p.PropertyName()
		}
		{
			p.SetState(622)
			p.Match(ServerScriptParserOpenParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(624)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&262688) != 0) || ((int64((_la-103)) & ^0x3f) == 0 && ((int64(1)<<(_la-103))&2106375) != 0) {
			{
				p.SetState(623)
				p.FormalParameterList()
			}

		}
		{
			p.SetState(626)
			p.Match(ServerScriptParserCloseParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(627)
			p.FunctionBody()
		}

	case 4:
		localctx = NewPropertyShorthandContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		p.SetState(630)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ServerScriptParserEllipsis {
			{
				p.SetState(629)
				p.Match(ServerScriptParserEllipsis)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(632)
			p.singleExpression(0)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPropertyNameContext is an interface to support dynamic dispatch.
type IPropertyNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IdentifierName() IIdentifierNameContext
	StringLiteral() antlr.TerminalNode
	NumericLiteral() INumericLiteralContext
	OpenBracket() antlr.TerminalNode
	SingleExpression() ISingleExpressionContext
	CloseBracket() antlr.TerminalNode

	// IsPropertyNameContext differentiates from other interfaces.
	IsPropertyNameContext()
}

type PropertyNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertyNameContext() *PropertyNameContext {
	var p = new(PropertyNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_propertyName
	return p
}

func InitEmptyPropertyNameContext(p *PropertyNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_propertyName
}

func (*PropertyNameContext) IsPropertyNameContext() {}

func NewPropertyNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyNameContext {
	var p = new(PropertyNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ServerScriptParserRULE_propertyName

	return p
}

func (s *PropertyNameContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyNameContext) IdentifierName() IIdentifierNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierNameContext)
}

func (s *PropertyNameContext) StringLiteral() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserStringLiteral, 0)
}

func (s *PropertyNameContext) NumericLiteral() INumericLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumericLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumericLiteralContext)
}

func (s *PropertyNameContext) OpenBracket() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserOpenBracket, 0)
}

func (s *PropertyNameContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *PropertyNameContext) CloseBracket() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserCloseBracket, 0)
}

func (s *PropertyNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertyNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.EnterPropertyName(s)
	}
}

func (s *PropertyNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.ExitPropertyName(s)
	}
}

func (s *PropertyNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ServerScriptParserVisitor:
		return t.VisitPropertyName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ServerScriptParser) PropertyName() (localctx IPropertyNameContext) {
	localctx = NewPropertyNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, ServerScriptParserRULE_propertyName)
	p.SetState(642)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ServerScriptParserNullLiteral, ServerScriptParserNaNLiteral, ServerScriptParserBooleanLiteral, ServerScriptParserBreak, ServerScriptParserDo, ServerScriptParserInstanceof, ServerScriptParserTypeof, ServerScriptParserCase, ServerScriptParserElse, ServerScriptParserNew, ServerScriptParserVar, ServerScriptParserLet, ServerScriptParserCatch, ServerScriptParserFinally, ServerScriptParserReturn, ServerScriptParserVoid, ServerScriptParserContinue, ServerScriptParserFor, ServerScriptParserSwitch, ServerScriptParserWhile, ServerScriptParserDebugger, ServerScriptParserFunction_, ServerScriptParserThis, ServerScriptParserWith, ServerScriptParserDefault, ServerScriptParserIf, ServerScriptParserThrow, ServerScriptParserDelete, ServerScriptParserIn, ServerScriptParserTry, ServerScriptParserAs, ServerScriptParserFrom, ServerScriptParserOf, ServerScriptParserClass, ServerScriptParserEnum, ServerScriptParserExtends, ServerScriptParserSuper, ServerScriptParserConst, ServerScriptParserExport, ServerScriptParserImport, ServerScriptParserAsync, ServerScriptParserSync, ServerScriptParserAwait, ServerScriptParserYield, ServerScriptParserImplements, ServerScriptParserPrivate, ServerScriptParserPublic, ServerScriptParserInterface, ServerScriptParserPackage, ServerScriptParserProtected, ServerScriptParserStatic, ServerScriptParserIdentifier:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(635)
			p.IdentifierName()
		}

	case ServerScriptParserStringLiteral:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(636)
			p.Match(ServerScriptParserStringLiteral)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ServerScriptParserDecimalLiteral, ServerScriptParserExponentLiteral, ServerScriptParserHexIntegerLiteral, ServerScriptParserOctalIntegerLiteral, ServerScriptParserBinaryIntegerLiteral:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(637)
			p.NumericLiteral()
		}

	case ServerScriptParserOpenBracket:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(638)
			p.Match(ServerScriptParserOpenBracket)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(639)
			p.singleExpression(0)
		}
		{
			p.SetState(640)
			p.Match(ServerScriptParserCloseBracket)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IArgumentsContext is an interface to support dynamic dispatch.
type IArgumentsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OpenParen() antlr.TerminalNode
	CloseParen() antlr.TerminalNode
	AllArgument() []IArgumentContext
	Argument(i int) IArgumentContext
	AllComma() []antlr.TerminalNode
	Comma(i int) antlr.TerminalNode

	// IsArgumentsContext differentiates from other interfaces.
	IsArgumentsContext()
}

type ArgumentsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArgumentsContext() *ArgumentsContext {
	var p = new(ArgumentsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_arguments
	return p
}

func InitEmptyArgumentsContext(p *ArgumentsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_arguments
}

func (*ArgumentsContext) IsArgumentsContext() {}

func NewArgumentsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArgumentsContext {
	var p = new(ArgumentsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ServerScriptParserRULE_arguments

	return p
}

func (s *ArgumentsContext) GetParser() antlr.Parser { return s.parser }

func (s *ArgumentsContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserOpenParen, 0)
}

func (s *ArgumentsContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserCloseParen, 0)
}

func (s *ArgumentsContext) AllArgument() []IArgumentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IArgumentContext); ok {
			len++
		}
	}

	tst := make([]IArgumentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IArgumentContext); ok {
			tst[i] = t.(IArgumentContext)
			i++
		}
	}

	return tst
}

func (s *ArgumentsContext) Argument(i int) IArgumentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArgumentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArgumentContext)
}

func (s *ArgumentsContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(ServerScriptParserComma)
}

func (s *ArgumentsContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(ServerScriptParserComma, i)
}

func (s *ArgumentsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArgumentsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArgumentsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.EnterArguments(s)
	}
}

func (s *ArgumentsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.ExitArguments(s)
	}
}

func (s *ArgumentsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ServerScriptParserVisitor:
		return t.VisitArguments(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ServerScriptParser) Arguments() (localctx IArgumentsContext) {
	localctx = NewArgumentsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, ServerScriptParserRULE_arguments)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(644)
		p.Match(ServerScriptParserOpenParen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(656)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-4611686018361064784) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&8076646901967228927) != 0) {
		{
			p.SetState(645)
			p.Argument()
		}
		p.SetState(650)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 67, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(646)
					p.Match(ServerScriptParserComma)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(647)
					p.Argument()
				}

			}
			p.SetState(652)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 67, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(654)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ServerScriptParserComma {
			{
				p.SetState(653)
				p.Match(ServerScriptParserComma)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	}
	{
		p.SetState(658)
		p.Match(ServerScriptParserCloseParen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IArgumentContext is an interface to support dynamic dispatch.
type IArgumentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SingleExpression() ISingleExpressionContext
	Identifier() IIdentifierContext
	Ellipsis() antlr.TerminalNode

	// IsArgumentContext differentiates from other interfaces.
	IsArgumentContext()
}

type ArgumentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArgumentContext() *ArgumentContext {
	var p = new(ArgumentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_argument
	return p
}

func InitEmptyArgumentContext(p *ArgumentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_argument
}

func (*ArgumentContext) IsArgumentContext() {}

func NewArgumentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArgumentContext {
	var p = new(ArgumentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ServerScriptParserRULE_argument

	return p
}

func (s *ArgumentContext) GetParser() antlr.Parser { return s.parser }

func (s *ArgumentContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *ArgumentContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ArgumentContext) Ellipsis() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserEllipsis, 0)
}

func (s *ArgumentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArgumentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArgumentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.EnterArgument(s)
	}
}

func (s *ArgumentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.ExitArgument(s)
	}
}

func (s *ArgumentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ServerScriptParserVisitor:
		return t.VisitArgument(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ServerScriptParser) Argument() (localctx IArgumentContext) {
	localctx = NewArgumentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, ServerScriptParserRULE_argument)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(661)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ServerScriptParserEllipsis {
		{
			p.SetState(660)
			p.Match(ServerScriptParserEllipsis)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(665)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 71, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(663)
			p.singleExpression(0)
		}

	case 2:
		{
			p.SetState(664)
			p.Identifier()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpressionSequenceContext is an interface to support dynamic dispatch.
type IExpressionSequenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSingleExpression() []ISingleExpressionContext
	SingleExpression(i int) ISingleExpressionContext
	AllComma() []antlr.TerminalNode
	Comma(i int) antlr.TerminalNode

	// IsExpressionSequenceContext differentiates from other interfaces.
	IsExpressionSequenceContext()
}

type ExpressionSequenceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionSequenceContext() *ExpressionSequenceContext {
	var p = new(ExpressionSequenceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_expressionSequence
	return p
}

func InitEmptyExpressionSequenceContext(p *ExpressionSequenceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_expressionSequence
}

func (*ExpressionSequenceContext) IsExpressionSequenceContext() {}

func NewExpressionSequenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionSequenceContext {
	var p = new(ExpressionSequenceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ServerScriptParserRULE_expressionSequence

	return p
}

func (s *ExpressionSequenceContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionSequenceContext) AllSingleExpression() []ISingleExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			len++
		}
	}

	tst := make([]ISingleExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISingleExpressionContext); ok {
			tst[i] = t.(ISingleExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ExpressionSequenceContext) SingleExpression(i int) ISingleExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *ExpressionSequenceContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(ServerScriptParserComma)
}

func (s *ExpressionSequenceContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(ServerScriptParserComma, i)
}

func (s *ExpressionSequenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionSequenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionSequenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.EnterExpressionSequence(s)
	}
}

func (s *ExpressionSequenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.ExitExpressionSequence(s)
	}
}

func (s *ExpressionSequenceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ServerScriptParserVisitor:
		return t.VisitExpressionSequence(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ServerScriptParser) ExpressionSequence() (localctx IExpressionSequenceContext) {
	localctx = NewExpressionSequenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, ServerScriptParserRULE_expressionSequence)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(667)
		p.singleExpression(0)
	}
	p.SetState(672)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 72, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(668)
				p.Match(ServerScriptParserComma)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(669)
				p.singleExpression(0)
			}

		}
		p.SetState(674)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 72, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISingleExpressionContext is an interface to support dynamic dispatch.
type ISingleExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsSingleExpressionContext differentiates from other interfaces.
	IsSingleExpressionContext()
}

type SingleExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySingleExpressionContext() *SingleExpressionContext {
	var p = new(SingleExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_singleExpression
	return p
}

func InitEmptySingleExpressionContext(p *SingleExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_singleExpression
}

func (*SingleExpressionContext) IsSingleExpressionContext() {}

func NewSingleExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SingleExpressionContext {
	var p = new(SingleExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ServerScriptParserRULE_singleExpression

	return p
}

func (s *SingleExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *SingleExpressionContext) CopyAll(ctx *SingleExpressionContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *SingleExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SingleExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type TemplateStringExpressionContext struct {
	SingleExpressionContext
}

func NewTemplateStringExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TemplateStringExpressionContext {
	var p = new(TemplateStringExpressionContext)

	InitEmptySingleExpressionContext(&p.SingleExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SingleExpressionContext))

	return p
}

func (s *TemplateStringExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TemplateStringExpressionContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *TemplateStringExpressionContext) TemplateStringLiteral() ITemplateStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITemplateStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITemplateStringLiteralContext)
}

func (s *TemplateStringExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.EnterTemplateStringExpression(s)
	}
}

func (s *TemplateStringExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.ExitTemplateStringExpression(s)
	}
}

func (s *TemplateStringExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ServerScriptParserVisitor:
		return t.VisitTemplateStringExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type TernaryExpressionContext struct {
	SingleExpressionContext
}

func NewTernaryExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TernaryExpressionContext {
	var p = new(TernaryExpressionContext)

	InitEmptySingleExpressionContext(&p.SingleExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SingleExpressionContext))

	return p
}

func (s *TernaryExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TernaryExpressionContext) AllSingleExpression() []ISingleExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			len++
		}
	}

	tst := make([]ISingleExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISingleExpressionContext); ok {
			tst[i] = t.(ISingleExpressionContext)
			i++
		}
	}

	return tst
}

func (s *TernaryExpressionContext) SingleExpression(i int) ISingleExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *TernaryExpressionContext) QuestionMark() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserQuestionMark, 0)
}

func (s *TernaryExpressionContext) Colon() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserColon, 0)
}

func (s *TernaryExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.EnterTernaryExpression(s)
	}
}

func (s *TernaryExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.ExitTernaryExpression(s)
	}
}

func (s *TernaryExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ServerScriptParserVisitor:
		return t.VisitTernaryExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type PowerExpressionContext struct {
	SingleExpressionContext
}

func NewPowerExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PowerExpressionContext {
	var p = new(PowerExpressionContext)

	InitEmptySingleExpressionContext(&p.SingleExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SingleExpressionContext))

	return p
}

func (s *PowerExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PowerExpressionContext) AllSingleExpression() []ISingleExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			len++
		}
	}

	tst := make([]ISingleExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISingleExpressionContext); ok {
			tst[i] = t.(ISingleExpressionContext)
			i++
		}
	}

	return tst
}

func (s *PowerExpressionContext) SingleExpression(i int) ISingleExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *PowerExpressionContext) Power() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserPower, 0)
}

func (s *PowerExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.EnterPowerExpression(s)
	}
}

func (s *PowerExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.ExitPowerExpression(s)
	}
}

func (s *PowerExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ServerScriptParserVisitor:
		return t.VisitPowerExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type PreIncrementExpressionContext struct {
	SingleExpressionContext
}

func NewPreIncrementExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PreIncrementExpressionContext {
	var p = new(PreIncrementExpressionContext)

	InitEmptySingleExpressionContext(&p.SingleExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SingleExpressionContext))

	return p
}

func (s *PreIncrementExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PreIncrementExpressionContext) PlusPlus() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserPlusPlus, 0)
}

func (s *PreIncrementExpressionContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *PreIncrementExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.EnterPreIncrementExpression(s)
	}
}

func (s *PreIncrementExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.ExitPreIncrementExpression(s)
	}
}

func (s *PreIncrementExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ServerScriptParserVisitor:
		return t.VisitPreIncrementExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type ObjectLiteralExpressionContext struct {
	SingleExpressionContext
}

func NewObjectLiteralExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ObjectLiteralExpressionContext {
	var p = new(ObjectLiteralExpressionContext)

	InitEmptySingleExpressionContext(&p.SingleExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SingleExpressionContext))

	return p
}

func (s *ObjectLiteralExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObjectLiteralExpressionContext) ObjectLiteral() IObjectLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObjectLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObjectLiteralContext)
}

func (s *ObjectLiteralExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.EnterObjectLiteralExpression(s)
	}
}

func (s *ObjectLiteralExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.ExitObjectLiteralExpression(s)
	}
}

func (s *ObjectLiteralExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ServerScriptParserVisitor:
		return t.VisitObjectLiteralExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type PrefixArgumentsExpressionContext struct {
	SingleExpressionContext
}

func NewPrefixArgumentsExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PrefixArgumentsExpressionContext {
	var p = new(PrefixArgumentsExpressionContext)

	InitEmptySingleExpressionContext(&p.SingleExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SingleExpressionContext))

	return p
}

func (s *PrefixArgumentsExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrefixArgumentsExpressionContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *PrefixArgumentsExpressionContext) Arguments() IArgumentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArgumentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArgumentsContext)
}

func (s *PrefixArgumentsExpressionContext) Sync() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserSync, 0)
}

func (s *PrefixArgumentsExpressionContext) Async() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserAsync, 0)
}

func (s *PrefixArgumentsExpressionContext) QuestionMarkDot() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserQuestionMarkDot, 0)
}

func (s *PrefixArgumentsExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.EnterPrefixArgumentsExpression(s)
	}
}

func (s *PrefixArgumentsExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.ExitPrefixArgumentsExpression(s)
	}
}

func (s *PrefixArgumentsExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ServerScriptParserVisitor:
		return t.VisitPrefixArgumentsExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type InExpressionContext struct {
	SingleExpressionContext
}

func NewInExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *InExpressionContext {
	var p = new(InExpressionContext)

	InitEmptySingleExpressionContext(&p.SingleExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SingleExpressionContext))

	return p
}

func (s *InExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InExpressionContext) AllSingleExpression() []ISingleExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			len++
		}
	}

	tst := make([]ISingleExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISingleExpressionContext); ok {
			tst[i] = t.(ISingleExpressionContext)
			i++
		}
	}

	return tst
}

func (s *InExpressionContext) SingleExpression(i int) ISingleExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *InExpressionContext) In() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserIn, 0)
}

func (s *InExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.EnterInExpression(s)
	}
}

func (s *InExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.ExitInExpression(s)
	}
}

func (s *InExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ServerScriptParserVisitor:
		return t.VisitInExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type NotExpressionContext struct {
	SingleExpressionContext
}

func NewNotExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NotExpressionContext {
	var p = new(NotExpressionContext)

	InitEmptySingleExpressionContext(&p.SingleExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SingleExpressionContext))

	return p
}

func (s *NotExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NotExpressionContext) Not() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserNot, 0)
}

func (s *NotExpressionContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *NotExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.EnterNotExpression(s)
	}
}

func (s *NotExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.ExitNotExpression(s)
	}
}

func (s *NotExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ServerScriptParserVisitor:
		return t.VisitNotExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type PreDecreaseExpressionContext struct {
	SingleExpressionContext
}

func NewPreDecreaseExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PreDecreaseExpressionContext {
	var p = new(PreDecreaseExpressionContext)

	InitEmptySingleExpressionContext(&p.SingleExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SingleExpressionContext))

	return p
}

func (s *PreDecreaseExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PreDecreaseExpressionContext) MinusMinus() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserMinusMinus, 0)
}

func (s *PreDecreaseExpressionContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *PreDecreaseExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.EnterPreDecreaseExpression(s)
	}
}

func (s *PreDecreaseExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.ExitPreDecreaseExpression(s)
	}
}

func (s *PreDecreaseExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ServerScriptParserVisitor:
		return t.VisitPreDecreaseExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type ArgumentsExpressionContext struct {
	SingleExpressionContext
}

func NewArgumentsExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ArgumentsExpressionContext {
	var p = new(ArgumentsExpressionContext)

	InitEmptySingleExpressionContext(&p.SingleExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SingleExpressionContext))

	return p
}

func (s *ArgumentsExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArgumentsExpressionContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *ArgumentsExpressionContext) Arguments() IArgumentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArgumentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArgumentsContext)
}

func (s *ArgumentsExpressionContext) QuestionMarkDot() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserQuestionMarkDot, 0)
}

func (s *ArgumentsExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.EnterArgumentsExpression(s)
	}
}

func (s *ArgumentsExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.ExitArgumentsExpression(s)
	}
}

func (s *ArgumentsExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ServerScriptParserVisitor:
		return t.VisitArgumentsExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type ThisExpressionContext struct {
	SingleExpressionContext
}

func NewThisExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ThisExpressionContext {
	var p = new(ThisExpressionContext)

	InitEmptySingleExpressionContext(&p.SingleExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SingleExpressionContext))

	return p
}

func (s *ThisExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ThisExpressionContext) This() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserThis, 0)
}

func (s *ThisExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.EnterThisExpression(s)
	}
}

func (s *ThisExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.ExitThisExpression(s)
	}
}

func (s *ThisExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ServerScriptParserVisitor:
		return t.VisitThisExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type LogicalExpressionContext struct {
	SingleExpressionContext
}

func NewLogicalExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LogicalExpressionContext {
	var p = new(LogicalExpressionContext)

	InitEmptySingleExpressionContext(&p.SingleExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SingleExpressionContext))

	return p
}

func (s *LogicalExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LogicalExpressionContext) AllSingleExpression() []ISingleExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			len++
		}
	}

	tst := make([]ISingleExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISingleExpressionContext); ok {
			tst[i] = t.(ISingleExpressionContext)
			i++
		}
	}

	return tst
}

func (s *LogicalExpressionContext) SingleExpression(i int) ISingleExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *LogicalExpressionContext) And() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserAnd, 0)
}

func (s *LogicalExpressionContext) Or() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserOr, 0)
}

func (s *LogicalExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.EnterLogicalExpression(s)
	}
}

func (s *LogicalExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.ExitLogicalExpression(s)
	}
}

func (s *LogicalExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ServerScriptParserVisitor:
		return t.VisitLogicalExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type FunctionExpressionContext struct {
	SingleExpressionContext
}

func NewFunctionExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *FunctionExpressionContext {
	var p = new(FunctionExpressionContext)

	InitEmptySingleExpressionContext(&p.SingleExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SingleExpressionContext))

	return p
}

func (s *FunctionExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionExpressionContext) AnonymousFunction() IAnonymousFunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnonymousFunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnonymousFunctionContext)
}

func (s *FunctionExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.EnterFunctionExpression(s)
	}
}

func (s *FunctionExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.ExitFunctionExpression(s)
	}
}

func (s *FunctionExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ServerScriptParserVisitor:
		return t.VisitFunctionExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type UnaryMinusExpressionContext struct {
	SingleExpressionContext
}

func NewUnaryMinusExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UnaryMinusExpressionContext {
	var p = new(UnaryMinusExpressionContext)

	InitEmptySingleExpressionContext(&p.SingleExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SingleExpressionContext))

	return p
}

func (s *UnaryMinusExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnaryMinusExpressionContext) Minus() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserMinus, 0)
}

func (s *UnaryMinusExpressionContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *UnaryMinusExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.EnterUnaryMinusExpression(s)
	}
}

func (s *UnaryMinusExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.ExitUnaryMinusExpression(s)
	}
}

func (s *UnaryMinusExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ServerScriptParserVisitor:
		return t.VisitUnaryMinusExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type AssignmentExpressionContext struct {
	SingleExpressionContext
}

func NewAssignmentExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AssignmentExpressionContext {
	var p = new(AssignmentExpressionContext)

	InitEmptySingleExpressionContext(&p.SingleExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SingleExpressionContext))

	return p
}

func (s *AssignmentExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignmentExpressionContext) AllSingleExpression() []ISingleExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			len++
		}
	}

	tst := make([]ISingleExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISingleExpressionContext); ok {
			tst[i] = t.(ISingleExpressionContext)
			i++
		}
	}

	return tst
}

func (s *AssignmentExpressionContext) SingleExpression(i int) ISingleExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *AssignmentExpressionContext) Assign() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserAssign, 0)
}

func (s *AssignmentExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.EnterAssignmentExpression(s)
	}
}

func (s *AssignmentExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.ExitAssignmentExpression(s)
	}
}

func (s *AssignmentExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ServerScriptParserVisitor:
		return t.VisitAssignmentExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type PostDecreaseExpressionContext struct {
	SingleExpressionContext
}

func NewPostDecreaseExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PostDecreaseExpressionContext {
	var p = new(PostDecreaseExpressionContext)

	InitEmptySingleExpressionContext(&p.SingleExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SingleExpressionContext))

	return p
}

func (s *PostDecreaseExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PostDecreaseExpressionContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *PostDecreaseExpressionContext) MinusMinus() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserMinusMinus, 0)
}

func (s *PostDecreaseExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.EnterPostDecreaseExpression(s)
	}
}

func (s *PostDecreaseExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.ExitPostDecreaseExpression(s)
	}
}

func (s *PostDecreaseExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ServerScriptParserVisitor:
		return t.VisitPostDecreaseExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type UnaryPlusExpressionContext struct {
	SingleExpressionContext
}

func NewUnaryPlusExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UnaryPlusExpressionContext {
	var p = new(UnaryPlusExpressionContext)

	InitEmptySingleExpressionContext(&p.SingleExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SingleExpressionContext))

	return p
}

func (s *UnaryPlusExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnaryPlusExpressionContext) Plus() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserPlus, 0)
}

func (s *UnaryPlusExpressionContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *UnaryPlusExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.EnterUnaryPlusExpression(s)
	}
}

func (s *UnaryPlusExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.ExitUnaryPlusExpression(s)
	}
}

func (s *UnaryPlusExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ServerScriptParserVisitor:
		return t.VisitUnaryPlusExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type DeleteExpressionContext struct {
	SingleExpressionContext
}

func NewDeleteExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DeleteExpressionContext {
	var p = new(DeleteExpressionContext)

	InitEmptySingleExpressionContext(&p.SingleExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SingleExpressionContext))

	return p
}

func (s *DeleteExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeleteExpressionContext) Delete() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserDelete, 0)
}

func (s *DeleteExpressionContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *DeleteExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.EnterDeleteExpression(s)
	}
}

func (s *DeleteExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.ExitDeleteExpression(s)
	}
}

func (s *DeleteExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ServerScriptParserVisitor:
		return t.VisitDeleteExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type EqualityExpressionContext struct {
	SingleExpressionContext
}

func NewEqualityExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *EqualityExpressionContext {
	var p = new(EqualityExpressionContext)

	InitEmptySingleExpressionContext(&p.SingleExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SingleExpressionContext))

	return p
}

func (s *EqualityExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EqualityExpressionContext) AllSingleExpression() []ISingleExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			len++
		}
	}

	tst := make([]ISingleExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISingleExpressionContext); ok {
			tst[i] = t.(ISingleExpressionContext)
			i++
		}
	}

	return tst
}

func (s *EqualityExpressionContext) SingleExpression(i int) ISingleExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *EqualityExpressionContext) Equals_() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserEquals_, 0)
}

func (s *EqualityExpressionContext) NotEquals() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserNotEquals, 0)
}

func (s *EqualityExpressionContext) IdentityEquals() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserIdentityEquals, 0)
}

func (s *EqualityExpressionContext) IdentityNotEquals() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserIdentityNotEquals, 0)
}

func (s *EqualityExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.EnterEqualityExpression(s)
	}
}

func (s *EqualityExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.ExitEqualityExpression(s)
	}
}

func (s *EqualityExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ServerScriptParserVisitor:
		return t.VisitEqualityExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type MultiplicativeExpressionContext struct {
	SingleExpressionContext
}

func NewMultiplicativeExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MultiplicativeExpressionContext {
	var p = new(MultiplicativeExpressionContext)

	InitEmptySingleExpressionContext(&p.SingleExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SingleExpressionContext))

	return p
}

func (s *MultiplicativeExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultiplicativeExpressionContext) AllSingleExpression() []ISingleExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			len++
		}
	}

	tst := make([]ISingleExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISingleExpressionContext); ok {
			tst[i] = t.(ISingleExpressionContext)
			i++
		}
	}

	return tst
}

func (s *MultiplicativeExpressionContext) SingleExpression(i int) ISingleExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *MultiplicativeExpressionContext) Multiply() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserMultiply, 0)
}

func (s *MultiplicativeExpressionContext) Divide() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserDivide, 0)
}

func (s *MultiplicativeExpressionContext) Modulus() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserModulus, 0)
}

func (s *MultiplicativeExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.EnterMultiplicativeExpression(s)
	}
}

func (s *MultiplicativeExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.ExitMultiplicativeExpression(s)
	}
}

func (s *MultiplicativeExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ServerScriptParserVisitor:
		return t.VisitMultiplicativeExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type BitShiftExpressionContext struct {
	SingleExpressionContext
}

func NewBitShiftExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BitShiftExpressionContext {
	var p = new(BitShiftExpressionContext)

	InitEmptySingleExpressionContext(&p.SingleExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SingleExpressionContext))

	return p
}

func (s *BitShiftExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BitShiftExpressionContext) AllSingleExpression() []ISingleExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			len++
		}
	}

	tst := make([]ISingleExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISingleExpressionContext); ok {
			tst[i] = t.(ISingleExpressionContext)
			i++
		}
	}

	return tst
}

func (s *BitShiftExpressionContext) SingleExpression(i int) ISingleExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *BitShiftExpressionContext) LeftShiftArithmetic() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserLeftShiftArithmetic, 0)
}

func (s *BitShiftExpressionContext) RightShiftArithmetic() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserRightShiftArithmetic, 0)
}

func (s *BitShiftExpressionContext) RightShiftLogical() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserRightShiftLogical, 0)
}

func (s *BitShiftExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.EnterBitShiftExpression(s)
	}
}

func (s *BitShiftExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.ExitBitShiftExpression(s)
	}
}

func (s *BitShiftExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ServerScriptParserVisitor:
		return t.VisitBitShiftExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type ParenthesizedExpressionContext struct {
	SingleExpressionContext
}

func NewParenthesizedExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ParenthesizedExpressionContext {
	var p = new(ParenthesizedExpressionContext)

	InitEmptySingleExpressionContext(&p.SingleExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SingleExpressionContext))

	return p
}

func (s *ParenthesizedExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParenthesizedExpressionContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserOpenParen, 0)
}

func (s *ParenthesizedExpressionContext) ExpressionSequence() IExpressionSequenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionSequenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionSequenceContext)
}

func (s *ParenthesizedExpressionContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserCloseParen, 0)
}

func (s *ParenthesizedExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.EnterParenthesizedExpression(s)
	}
}

func (s *ParenthesizedExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.ExitParenthesizedExpression(s)
	}
}

func (s *ParenthesizedExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ServerScriptParserVisitor:
		return t.VisitParenthesizedExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type AdditiveExpressionContext struct {
	SingleExpressionContext
}

func NewAdditiveExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AdditiveExpressionContext {
	var p = new(AdditiveExpressionContext)

	InitEmptySingleExpressionContext(&p.SingleExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SingleExpressionContext))

	return p
}

func (s *AdditiveExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdditiveExpressionContext) AllSingleExpression() []ISingleExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			len++
		}
	}

	tst := make([]ISingleExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISingleExpressionContext); ok {
			tst[i] = t.(ISingleExpressionContext)
			i++
		}
	}

	return tst
}

func (s *AdditiveExpressionContext) SingleExpression(i int) ISingleExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *AdditiveExpressionContext) Plus() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserPlus, 0)
}

func (s *AdditiveExpressionContext) Minus() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserMinus, 0)
}

func (s *AdditiveExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.EnterAdditiveExpression(s)
	}
}

func (s *AdditiveExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.ExitAdditiveExpression(s)
	}
}

func (s *AdditiveExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ServerScriptParserVisitor:
		return t.VisitAdditiveExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type RelationalExpressionContext struct {
	SingleExpressionContext
}

func NewRelationalExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RelationalExpressionContext {
	var p = new(RelationalExpressionContext)

	InitEmptySingleExpressionContext(&p.SingleExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SingleExpressionContext))

	return p
}

func (s *RelationalExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationalExpressionContext) AllSingleExpression() []ISingleExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			len++
		}
	}

	tst := make([]ISingleExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISingleExpressionContext); ok {
			tst[i] = t.(ISingleExpressionContext)
			i++
		}
	}

	return tst
}

func (s *RelationalExpressionContext) SingleExpression(i int) ISingleExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *RelationalExpressionContext) LessThan() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserLessThan, 0)
}

func (s *RelationalExpressionContext) MoreThan() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserMoreThan, 0)
}

func (s *RelationalExpressionContext) LessThanEquals() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserLessThanEquals, 0)
}

func (s *RelationalExpressionContext) GreaterThanEquals() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserGreaterThanEquals, 0)
}

func (s *RelationalExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.EnterRelationalExpression(s)
	}
}

func (s *RelationalExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.ExitRelationalExpression(s)
	}
}

func (s *RelationalExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ServerScriptParserVisitor:
		return t.VisitRelationalExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type PostIncrementExpressionContext struct {
	SingleExpressionContext
}

func NewPostIncrementExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PostIncrementExpressionContext {
	var p = new(PostIncrementExpressionContext)

	InitEmptySingleExpressionContext(&p.SingleExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SingleExpressionContext))

	return p
}

func (s *PostIncrementExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PostIncrementExpressionContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *PostIncrementExpressionContext) PlusPlus() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserPlusPlus, 0)
}

func (s *PostIncrementExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.EnterPostIncrementExpression(s)
	}
}

func (s *PostIncrementExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.ExitPostIncrementExpression(s)
	}
}

func (s *PostIncrementExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ServerScriptParserVisitor:
		return t.VisitPostIncrementExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type BitNotExpressionContext struct {
	SingleExpressionContext
}

func NewBitNotExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BitNotExpressionContext {
	var p = new(BitNotExpressionContext)

	InitEmptySingleExpressionContext(&p.SingleExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SingleExpressionContext))

	return p
}

func (s *BitNotExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BitNotExpressionContext) BitNot() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserBitNot, 0)
}

func (s *BitNotExpressionContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *BitNotExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.EnterBitNotExpression(s)
	}
}

func (s *BitNotExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.ExitBitNotExpression(s)
	}
}

func (s *BitNotExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ServerScriptParserVisitor:
		return t.VisitBitNotExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type NewExpressionContext struct {
	SingleExpressionContext
}

func NewNewExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NewExpressionContext {
	var p = new(NewExpressionContext)

	InitEmptySingleExpressionContext(&p.SingleExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SingleExpressionContext))

	return p
}

func (s *NewExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NewExpressionContext) New() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserNew, 0)
}

func (s *NewExpressionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *NewExpressionContext) Arguments() IArgumentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArgumentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArgumentsContext)
}

func (s *NewExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.EnterNewExpression(s)
	}
}

func (s *NewExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.ExitNewExpression(s)
	}
}

func (s *NewExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ServerScriptParserVisitor:
		return t.VisitNewExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type LiteralExpressionContext struct {
	SingleExpressionContext
}

func NewLiteralExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LiteralExpressionContext {
	var p = new(LiteralExpressionContext)

	InitEmptySingleExpressionContext(&p.SingleExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SingleExpressionContext))

	return p
}

func (s *LiteralExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralExpressionContext) Literal() ILiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *LiteralExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.EnterLiteralExpression(s)
	}
}

func (s *LiteralExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.ExitLiteralExpression(s)
	}
}

func (s *LiteralExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ServerScriptParserVisitor:
		return t.VisitLiteralExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type ArrayLiteralExpressionContext struct {
	SingleExpressionContext
}

func NewArrayLiteralExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ArrayLiteralExpressionContext {
	var p = new(ArrayLiteralExpressionContext)

	InitEmptySingleExpressionContext(&p.SingleExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SingleExpressionContext))

	return p
}

func (s *ArrayLiteralExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayLiteralExpressionContext) ArrayLiteral() IArrayLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayLiteralContext)
}

func (s *ArrayLiteralExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.EnterArrayLiteralExpression(s)
	}
}

func (s *ArrayLiteralExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.ExitArrayLiteralExpression(s)
	}
}

func (s *ArrayLiteralExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ServerScriptParserVisitor:
		return t.VisitArrayLiteralExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type MemberDotExpressionContext struct {
	SingleExpressionContext
}

func NewMemberDotExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MemberDotExpressionContext {
	var p = new(MemberDotExpressionContext)

	InitEmptySingleExpressionContext(&p.SingleExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SingleExpressionContext))

	return p
}

func (s *MemberDotExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MemberDotExpressionContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *MemberDotExpressionContext) IdentifierName() IIdentifierNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierNameContext)
}

func (s *MemberDotExpressionContext) Dot() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserDot, 0)
}

func (s *MemberDotExpressionContext) QuestionMarkDot() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserQuestionMarkDot, 0)
}

func (s *MemberDotExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.EnterMemberDotExpression(s)
	}
}

func (s *MemberDotExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.ExitMemberDotExpression(s)
	}
}

func (s *MemberDotExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ServerScriptParserVisitor:
		return t.VisitMemberDotExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type MemberIndexExpressionContext struct {
	SingleExpressionContext
}

func NewMemberIndexExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MemberIndexExpressionContext {
	var p = new(MemberIndexExpressionContext)

	InitEmptySingleExpressionContext(&p.SingleExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SingleExpressionContext))

	return p
}

func (s *MemberIndexExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MemberIndexExpressionContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *MemberIndexExpressionContext) OpenBracket() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserOpenBracket, 0)
}

func (s *MemberIndexExpressionContext) ExpressionSequence() IExpressionSequenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionSequenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionSequenceContext)
}

func (s *MemberIndexExpressionContext) CloseBracket() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserCloseBracket, 0)
}

func (s *MemberIndexExpressionContext) QuestionMarkDot() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserQuestionMarkDot, 0)
}

func (s *MemberIndexExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.EnterMemberIndexExpression(s)
	}
}

func (s *MemberIndexExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.ExitMemberIndexExpression(s)
	}
}

func (s *MemberIndexExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ServerScriptParserVisitor:
		return t.VisitMemberIndexExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type IdentifierExpressionContext struct {
	SingleExpressionContext
}

func NewIdentifierExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IdentifierExpressionContext {
	var p = new(IdentifierExpressionContext)

	InitEmptySingleExpressionContext(&p.SingleExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SingleExpressionContext))

	return p
}

func (s *IdentifierExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierExpressionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *IdentifierExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.EnterIdentifierExpression(s)
	}
}

func (s *IdentifierExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.ExitIdentifierExpression(s)
	}
}

func (s *IdentifierExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ServerScriptParserVisitor:
		return t.VisitIdentifierExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type BitExpressionContext struct {
	SingleExpressionContext
}

func NewBitExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BitExpressionContext {
	var p = new(BitExpressionContext)

	InitEmptySingleExpressionContext(&p.SingleExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SingleExpressionContext))

	return p
}

func (s *BitExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BitExpressionContext) AllSingleExpression() []ISingleExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			len++
		}
	}

	tst := make([]ISingleExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISingleExpressionContext); ok {
			tst[i] = t.(ISingleExpressionContext)
			i++
		}
	}

	return tst
}

func (s *BitExpressionContext) SingleExpression(i int) ISingleExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *BitExpressionContext) BitAnd() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserBitAnd, 0)
}

func (s *BitExpressionContext) BitXOr() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserBitXOr, 0)
}

func (s *BitExpressionContext) BitOr() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserBitOr, 0)
}

func (s *BitExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.EnterBitExpression(s)
	}
}

func (s *BitExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.ExitBitExpression(s)
	}
}

func (s *BitExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ServerScriptParserVisitor:
		return t.VisitBitExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type AssignmentOperatorExpressionContext struct {
	SingleExpressionContext
}

func NewAssignmentOperatorExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AssignmentOperatorExpressionContext {
	var p = new(AssignmentOperatorExpressionContext)

	InitEmptySingleExpressionContext(&p.SingleExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SingleExpressionContext))

	return p
}

func (s *AssignmentOperatorExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignmentOperatorExpressionContext) AllSingleExpression() []ISingleExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			len++
		}
	}

	tst := make([]ISingleExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISingleExpressionContext); ok {
			tst[i] = t.(ISingleExpressionContext)
			i++
		}
	}

	return tst
}

func (s *AssignmentOperatorExpressionContext) SingleExpression(i int) ISingleExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *AssignmentOperatorExpressionContext) AssignmentOperator() IAssignmentOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentOperatorContext)
}

func (s *AssignmentOperatorExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.EnterAssignmentOperatorExpression(s)
	}
}

func (s *AssignmentOperatorExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.ExitAssignmentOperatorExpression(s)
	}
}

func (s *AssignmentOperatorExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ServerScriptParserVisitor:
		return t.VisitAssignmentOperatorExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type CoalesceExpressionContext struct {
	SingleExpressionContext
}

func NewCoalesceExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CoalesceExpressionContext {
	var p = new(CoalesceExpressionContext)

	InitEmptySingleExpressionContext(&p.SingleExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*SingleExpressionContext))

	return p
}

func (s *CoalesceExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CoalesceExpressionContext) AllSingleExpression() []ISingleExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			len++
		}
	}

	tst := make([]ISingleExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISingleExpressionContext); ok {
			tst[i] = t.(ISingleExpressionContext)
			i++
		}
	}

	return tst
}

func (s *CoalesceExpressionContext) SingleExpression(i int) ISingleExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *CoalesceExpressionContext) NullCoalesce() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserNullCoalesce, 0)
}

func (s *CoalesceExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.EnterCoalesceExpression(s)
	}
}

func (s *CoalesceExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.ExitCoalesceExpression(s)
	}
}

func (s *CoalesceExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ServerScriptParserVisitor:
		return t.VisitCoalesceExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ServerScriptParser) SingleExpression() (localctx ISingleExpressionContext) {
	return p.singleExpression(0)
}

func (p *ServerScriptParser) singleExpression(_p int) (localctx ISingleExpressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewSingleExpressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx ISingleExpressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 126
	p.EnterRecursionRule(localctx, 126, ServerScriptParserRULE_singleExpression, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(711)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 74, p.GetParserRuleContext()) {
	case 1:
		localctx = NewFunctionExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx

		{
			p.SetState(676)
			p.AnonymousFunction()
		}

	case 2:
		localctx = NewPrefixArgumentsExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(677)
			_la = p.GetTokenStream().LA(1)

			if !(_la == ServerScriptParserAsync || _la == ServerScriptParserSync) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(678)
			p.singleExpression(0)
		}
		p.SetState(680)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ServerScriptParserQuestionMarkDot {
			{
				p.SetState(679)
				p.Match(ServerScriptParserQuestionMarkDot)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(682)
			p.Arguments()
		}

	case 3:
		localctx = NewNewExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(684)
			p.Match(ServerScriptParserNew)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(685)
			p.Identifier()
		}
		{
			p.SetState(686)
			p.Arguments()
		}

	case 4:
		localctx = NewDeleteExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(688)
			p.Match(ServerScriptParserDelete)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(689)
			p.singleExpression(27)
		}

	case 5:
		localctx = NewPreIncrementExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(690)
			p.Match(ServerScriptParserPlusPlus)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(691)
			p.singleExpression(26)
		}

	case 6:
		localctx = NewPreDecreaseExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(692)
			p.Match(ServerScriptParserMinusMinus)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(693)
			p.singleExpression(25)
		}

	case 7:
		localctx = NewUnaryPlusExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(694)
			p.Match(ServerScriptParserPlus)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(695)
			p.singleExpression(24)
		}

	case 8:
		localctx = NewUnaryMinusExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(696)
			p.Match(ServerScriptParserMinus)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(697)
			p.singleExpression(23)
		}

	case 9:
		localctx = NewBitNotExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(698)
			p.Match(ServerScriptParserBitNot)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(699)
			p.singleExpression(22)
		}

	case 10:
		localctx = NewNotExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(700)
			p.Match(ServerScriptParserNot)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(701)
			p.singleExpression(21)
		}

	case 11:
		localctx = NewThisExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(702)
			p.Match(ServerScriptParserThis)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 12:
		localctx = NewIdentifierExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(703)
			p.Identifier()
		}

	case 13:
		localctx = NewLiteralExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(704)
			p.Literal()
		}

	case 14:
		localctx = NewArrayLiteralExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(705)
			p.ArrayLiteral()
		}

	case 15:
		localctx = NewObjectLiteralExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(706)
			p.ObjectLiteral()
		}

	case 16:
		localctx = NewParenthesizedExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(707)
			p.Match(ServerScriptParserOpenParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(708)
			p.ExpressionSequence()
		}
		{
			p.SetState(709)
			p.Match(ServerScriptParserCloseParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(782)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 78, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(780)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 77, p.GetParserRuleContext()) {
			case 1:
				localctx = NewPowerExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, ServerScriptParserRULE_singleExpression)
				p.SetState(713)

				if !(p.Precpred(p.GetParserRuleContext(), 20)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 20)", ""))
					goto errorExit
				}
				{
					p.SetState(714)
					p.Match(ServerScriptParserPower)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(715)
					p.singleExpression(20)
				}

			case 2:
				localctx = NewMultiplicativeExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, ServerScriptParserRULE_singleExpression)
				p.SetState(716)

				if !(p.Precpred(p.GetParserRuleContext(), 19)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 19)", ""))
					goto errorExit
				}
				{
					p.SetState(717)
					_la = p.GetTokenStream().LA(1)

					if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&469762048) != 0) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(718)
					p.singleExpression(20)
				}

			case 3:
				localctx = NewAdditiveExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, ServerScriptParserRULE_singleExpression)
				p.SetState(719)

				if !(p.Precpred(p.GetParserRuleContext(), 18)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 18)", ""))
					goto errorExit
				}
				{
					p.SetState(720)
					_la = p.GetTokenStream().LA(1)

					if !(_la == ServerScriptParserPlus || _la == ServerScriptParserMinus) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(721)
					p.singleExpression(19)
				}

			case 4:
				localctx = NewCoalesceExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, ServerScriptParserRULE_singleExpression)
				p.SetState(722)

				if !(p.Precpred(p.GetParserRuleContext(), 17)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 17)", ""))
					goto errorExit
				}
				{
					p.SetState(723)
					p.Match(ServerScriptParserNullCoalesce)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(724)
					p.singleExpression(18)
				}

			case 5:
				localctx = NewBitShiftExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, ServerScriptParserRULE_singleExpression)
				p.SetState(725)

				if !(p.Precpred(p.GetParserRuleContext(), 16)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 16)", ""))
					goto errorExit
				}
				{
					p.SetState(726)
					_la = p.GetTokenStream().LA(1)

					if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&30064771072) != 0) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(727)
					p.singleExpression(17)
				}

			case 6:
				localctx = NewRelationalExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, ServerScriptParserRULE_singleExpression)
				p.SetState(728)

				if !(p.Precpred(p.GetParserRuleContext(), 15)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 15)", ""))
					goto errorExit
				}
				{
					p.SetState(729)
					_la = p.GetTokenStream().LA(1)

					if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&515396075520) != 0) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(730)
					p.singleExpression(16)
				}

			case 7:
				localctx = NewInExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, ServerScriptParserRULE_singleExpression)
				p.SetState(731)

				if !(p.Precpred(p.GetParserRuleContext(), 14)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 14)", ""))
					goto errorExit
				}
				{
					p.SetState(732)
					p.Match(ServerScriptParserIn)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(733)
					p.singleExpression(15)
				}

			case 8:
				localctx = NewEqualityExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, ServerScriptParserRULE_singleExpression)
				p.SetState(734)

				if !(p.Precpred(p.GetParserRuleContext(), 13)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 13)", ""))
					goto errorExit
				}
				{
					p.SetState(735)
					_la = p.GetTokenStream().LA(1)

					if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&8246337208320) != 0) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(736)
					p.singleExpression(14)
				}

			case 9:
				localctx = NewBitExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, ServerScriptParserRULE_singleExpression)
				p.SetState(737)

				if !(p.Precpred(p.GetParserRuleContext(), 12)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 12)", ""))
					goto errorExit
				}
				{
					p.SetState(738)
					_la = p.GetTokenStream().LA(1)

					if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&61572651155456) != 0) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(739)
					p.singleExpression(13)
				}

			case 10:
				localctx = NewLogicalExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, ServerScriptParserRULE_singleExpression)
				p.SetState(740)

				if !(p.Precpred(p.GetParserRuleContext(), 11)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 11)", ""))
					goto errorExit
				}
				{
					p.SetState(741)
					_la = p.GetTokenStream().LA(1)

					if !(_la == ServerScriptParserAnd || _la == ServerScriptParserOr) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(742)
					p.singleExpression(12)
				}

			case 11:
				localctx = NewTernaryExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, ServerScriptParserRULE_singleExpression)
				p.SetState(743)

				if !(p.Precpred(p.GetParserRuleContext(), 10)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 10)", ""))
					goto errorExit
				}
				{
					p.SetState(744)
					p.Match(ServerScriptParserQuestionMark)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(745)
					p.singleExpression(0)
				}
				{
					p.SetState(746)
					p.Match(ServerScriptParserColon)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(747)
					p.singleExpression(11)
				}

			case 12:
				localctx = NewAssignmentExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, ServerScriptParserRULE_singleExpression)
				p.SetState(749)

				if !(p.Precpred(p.GetParserRuleContext(), 9)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 9)", ""))
					goto errorExit
				}
				{
					p.SetState(750)
					p.Match(ServerScriptParserAssign)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(751)
					p.singleExpression(9)
				}

			case 13:
				localctx = NewAssignmentOperatorExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, ServerScriptParserRULE_singleExpression)
				p.SetState(752)

				if !(p.Precpred(p.GetParserRuleContext(), 8)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 8)", ""))
					goto errorExit
				}
				{
					p.SetState(753)
					p.AssignmentOperator()
				}
				{
					p.SetState(754)
					p.singleExpression(8)
				}

			case 14:
				localctx = NewMemberIndexExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, ServerScriptParserRULE_singleExpression)
				p.SetState(756)

				if !(p.Precpred(p.GetParserRuleContext(), 34)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 34)", ""))
					goto errorExit
				}
				p.SetState(758)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == ServerScriptParserQuestionMarkDot {
					{
						p.SetState(757)
						p.Match(ServerScriptParserQuestionMarkDot)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				}
				{
					p.SetState(760)
					p.Match(ServerScriptParserOpenBracket)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(761)
					p.ExpressionSequence()
				}
				{
					p.SetState(762)
					p.Match(ServerScriptParserCloseBracket)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case 15:
				localctx = NewMemberDotExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, ServerScriptParserRULE_singleExpression)
				p.SetState(764)

				if !(p.Precpred(p.GetParserRuleContext(), 33)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 33)", ""))
					goto errorExit
				}
				{
					p.SetState(765)
					_la = p.GetTokenStream().LA(1)

					if !(_la == ServerScriptParserQuestionMarkDot || _la == ServerScriptParserDot) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(766)
					p.IdentifierName()
				}

			case 16:
				localctx = NewArgumentsExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, ServerScriptParserRULE_singleExpression)
				p.SetState(767)

				if !(p.Precpred(p.GetParserRuleContext(), 32)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 32)", ""))
					goto errorExit
				}
				p.SetState(769)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == ServerScriptParserQuestionMarkDot {
					{
						p.SetState(768)
						p.Match(ServerScriptParserQuestionMarkDot)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				}
				{
					p.SetState(771)
					p.Arguments()
				}

			case 17:
				localctx = NewPostIncrementExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, ServerScriptParserRULE_singleExpression)
				p.SetState(772)

				if !(p.Precpred(p.GetParserRuleContext(), 29)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 29)", ""))
					goto errorExit
				}
				p.SetState(773)

				if !(p.notLineTerminator()) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.notLineTerminator()", ""))
					goto errorExit
				}
				{
					p.SetState(774)
					p.Match(ServerScriptParserPlusPlus)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case 18:
				localctx = NewPostDecreaseExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, ServerScriptParserRULE_singleExpression)
				p.SetState(775)

				if !(p.Precpred(p.GetParserRuleContext(), 28)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 28)", ""))
					goto errorExit
				}
				p.SetState(776)

				if !(p.notLineTerminator()) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.notLineTerminator()", ""))
					goto errorExit
				}
				{
					p.SetState(777)
					p.Match(ServerScriptParserMinusMinus)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case 19:
				localctx = NewTemplateStringExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, ServerScriptParserRULE_singleExpression)
				p.SetState(778)

				if !(p.Precpred(p.GetParserRuleContext(), 7)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 7)", ""))
					goto errorExit
				}
				{
					p.SetState(779)
					p.TemplateStringLiteral()
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(784)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 78, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAssignableContext is an interface to support dynamic dispatch.
type IAssignableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	ArrayLiteral() IArrayLiteralContext
	ObjectLiteral() IObjectLiteralContext

	// IsAssignableContext differentiates from other interfaces.
	IsAssignableContext()
}

type AssignableContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignableContext() *AssignableContext {
	var p = new(AssignableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_assignable
	return p
}

func InitEmptyAssignableContext(p *AssignableContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_assignable
}

func (*AssignableContext) IsAssignableContext() {}

func NewAssignableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignableContext {
	var p = new(AssignableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ServerScriptParserRULE_assignable

	return p
}

func (s *AssignableContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignableContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AssignableContext) ArrayLiteral() IArrayLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayLiteralContext)
}

func (s *AssignableContext) ObjectLiteral() IObjectLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObjectLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObjectLiteralContext)
}

func (s *AssignableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssignableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.EnterAssignable(s)
	}
}

func (s *AssignableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.ExitAssignable(s)
	}
}

func (s *AssignableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ServerScriptParserVisitor:
		return t.VisitAssignable(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ServerScriptParser) Assignable() (localctx IAssignableContext) {
	localctx = NewAssignableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, ServerScriptParserRULE_assignable)
	p.SetState(788)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ServerScriptParserAs, ServerScriptParserFrom, ServerScriptParserOf, ServerScriptParserAsync, ServerScriptParserYield, ServerScriptParserIdentifier:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(785)
			p.Identifier()
		}

	case ServerScriptParserOpenBracket:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(786)
			p.ArrayLiteral()
		}

	case ServerScriptParserOpenBrace:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(787)
			p.ObjectLiteral()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IObjectLiteralContext is an interface to support dynamic dispatch.
type IObjectLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OpenBrace() antlr.TerminalNode
	CloseBrace() antlr.TerminalNode
	AllPropertyAssignment() []IPropertyAssignmentContext
	PropertyAssignment(i int) IPropertyAssignmentContext
	AllComma() []antlr.TerminalNode
	Comma(i int) antlr.TerminalNode

	// IsObjectLiteralContext differentiates from other interfaces.
	IsObjectLiteralContext()
}

type ObjectLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObjectLiteralContext() *ObjectLiteralContext {
	var p = new(ObjectLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_objectLiteral
	return p
}

func InitEmptyObjectLiteralContext(p *ObjectLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_objectLiteral
}

func (*ObjectLiteralContext) IsObjectLiteralContext() {}

func NewObjectLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObjectLiteralContext {
	var p = new(ObjectLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ServerScriptParserRULE_objectLiteral

	return p
}

func (s *ObjectLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *ObjectLiteralContext) OpenBrace() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserOpenBrace, 0)
}

func (s *ObjectLiteralContext) CloseBrace() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserCloseBrace, 0)
}

func (s *ObjectLiteralContext) AllPropertyAssignment() []IPropertyAssignmentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPropertyAssignmentContext); ok {
			len++
		}
	}

	tst := make([]IPropertyAssignmentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPropertyAssignmentContext); ok {
			tst[i] = t.(IPropertyAssignmentContext)
			i++
		}
	}

	return tst
}

func (s *ObjectLiteralContext) PropertyAssignment(i int) IPropertyAssignmentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyAssignmentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyAssignmentContext)
}

func (s *ObjectLiteralContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(ServerScriptParserComma)
}

func (s *ObjectLiteralContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(ServerScriptParserComma, i)
}

func (s *ObjectLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObjectLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ObjectLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.EnterObjectLiteral(s)
	}
}

func (s *ObjectLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.ExitObjectLiteral(s)
	}
}

func (s *ObjectLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ServerScriptParserVisitor:
		return t.VisitObjectLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ServerScriptParser) ObjectLiteral() (localctx IObjectLiteralContext) {
	localctx = NewObjectLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, ServerScriptParserRULE_objectLiteral)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(790)
		p.Match(ServerScriptParserOpenBrace)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(802)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-4611686018293955920) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&9223372036854775807) != 0) {
		{
			p.SetState(791)
			p.PropertyAssignment()
		}
		p.SetState(796)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 80, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(792)
					p.Match(ServerScriptParserComma)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(793)
					p.PropertyAssignment()
				}

			}
			p.SetState(798)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 80, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(800)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ServerScriptParserComma {
			{
				p.SetState(799)
				p.Match(ServerScriptParserComma)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	}
	{
		p.SetState(804)
		p.Match(ServerScriptParserCloseBrace)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAnonymousFunctionContext is an interface to support dynamic dispatch.
type IAnonymousFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsAnonymousFunctionContext differentiates from other interfaces.
	IsAnonymousFunctionContext()
}

type AnonymousFunctionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnonymousFunctionContext() *AnonymousFunctionContext {
	var p = new(AnonymousFunctionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_anonymousFunction
	return p
}

func InitEmptyAnonymousFunctionContext(p *AnonymousFunctionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_anonymousFunction
}

func (*AnonymousFunctionContext) IsAnonymousFunctionContext() {}

func NewAnonymousFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnonymousFunctionContext {
	var p = new(AnonymousFunctionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ServerScriptParserRULE_anonymousFunction

	return p
}

func (s *AnonymousFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *AnonymousFunctionContext) CopyAll(ctx *AnonymousFunctionContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *AnonymousFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnonymousFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type AnonymousFunctionDeclContext struct {
	AnonymousFunctionContext
}

func NewAnonymousFunctionDeclContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AnonymousFunctionDeclContext {
	var p = new(AnonymousFunctionDeclContext)

	InitEmptyAnonymousFunctionContext(&p.AnonymousFunctionContext)
	p.parser = parser
	p.CopyAll(ctx.(*AnonymousFunctionContext))

	return p
}

func (s *AnonymousFunctionDeclContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnonymousFunctionDeclContext) Function_() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserFunction_, 0)
}

func (s *AnonymousFunctionDeclContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserOpenParen, 0)
}

func (s *AnonymousFunctionDeclContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserCloseParen, 0)
}

func (s *AnonymousFunctionDeclContext) FunctionBody() IFunctionBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionBodyContext)
}

func (s *AnonymousFunctionDeclContext) Multiply() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserMultiply, 0)
}

func (s *AnonymousFunctionDeclContext) FormalParameterList() IFormalParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFormalParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFormalParameterListContext)
}

func (s *AnonymousFunctionDeclContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.EnterAnonymousFunctionDecl(s)
	}
}

func (s *AnonymousFunctionDeclContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.ExitAnonymousFunctionDecl(s)
	}
}

func (s *AnonymousFunctionDeclContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ServerScriptParserVisitor:
		return t.VisitAnonymousFunctionDecl(s)

	default:
		return t.VisitChildren(s)
	}
}

type ArrowFunctionContext struct {
	AnonymousFunctionContext
}

func NewArrowFunctionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ArrowFunctionContext {
	var p = new(ArrowFunctionContext)

	InitEmptyAnonymousFunctionContext(&p.AnonymousFunctionContext)
	p.parser = parser
	p.CopyAll(ctx.(*AnonymousFunctionContext))

	return p
}

func (s *ArrowFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrowFunctionContext) ArrowFunctionParameters() IArrowFunctionParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrowFunctionParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrowFunctionParametersContext)
}

func (s *ArrowFunctionContext) ARROW() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserARROW, 0)
}

func (s *ArrowFunctionContext) FunctionBody() IFunctionBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionBodyContext)
}

func (s *ArrowFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.EnterArrowFunction(s)
	}
}

func (s *ArrowFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.ExitArrowFunction(s)
	}
}

func (s *ArrowFunctionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ServerScriptParserVisitor:
		return t.VisitArrowFunction(s)

	default:
		return t.VisitChildren(s)
	}
}

type ArrowSingleFunctionContext struct {
	AnonymousFunctionContext
}

func NewArrowSingleFunctionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ArrowSingleFunctionContext {
	var p = new(ArrowSingleFunctionContext)

	InitEmptyAnonymousFunctionContext(&p.AnonymousFunctionContext)
	p.parser = parser
	p.CopyAll(ctx.(*AnonymousFunctionContext))

	return p
}

func (s *ArrowSingleFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrowSingleFunctionContext) ArrowFunctionParameters() IArrowFunctionParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrowFunctionParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrowFunctionParametersContext)
}

func (s *ArrowSingleFunctionContext) ARROW() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserARROW, 0)
}

func (s *ArrowSingleFunctionContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *ArrowSingleFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.EnterArrowSingleFunction(s)
	}
}

func (s *ArrowSingleFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.ExitArrowSingleFunction(s)
	}
}

func (s *ArrowSingleFunctionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ServerScriptParserVisitor:
		return t.VisitArrowSingleFunction(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ServerScriptParser) AnonymousFunction() (localctx IAnonymousFunctionContext) {
	localctx = NewAnonymousFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, ServerScriptParserRULE_anonymousFunction)
	var _la int

	p.SetState(824)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 85, p.GetParserRuleContext()) {
	case 1:
		localctx = NewAnonymousFunctionDeclContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(806)
			p.Match(ServerScriptParserFunction_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(808)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ServerScriptParserMultiply {
			{
				p.SetState(807)
				p.Match(ServerScriptParserMultiply)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(810)
			p.Match(ServerScriptParserOpenParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(812)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&262688) != 0) || ((int64((_la-103)) & ^0x3f) == 0 && ((int64(1)<<(_la-103))&2106375) != 0) {
			{
				p.SetState(811)
				p.FormalParameterList()
			}

		}
		{
			p.SetState(814)
			p.Match(ServerScriptParserCloseParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(815)
			p.FunctionBody()
		}

	case 2:
		localctx = NewArrowFunctionContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(816)
			p.ArrowFunctionParameters()
		}
		{
			p.SetState(817)
			p.Match(ServerScriptParserARROW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(818)
			p.FunctionBody()
		}

	case 3:
		localctx = NewArrowSingleFunctionContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(820)
			p.ArrowFunctionParameters()
		}
		{
			p.SetState(821)
			p.Match(ServerScriptParserARROW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(822)
			p.singleExpression(0)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IArrowFunctionParametersContext is an interface to support dynamic dispatch.
type IArrowFunctionParametersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	OpenParen() antlr.TerminalNode
	CloseParen() antlr.TerminalNode
	FormalParameterList() IFormalParameterListContext

	// IsArrowFunctionParametersContext differentiates from other interfaces.
	IsArrowFunctionParametersContext()
}

type ArrowFunctionParametersContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrowFunctionParametersContext() *ArrowFunctionParametersContext {
	var p = new(ArrowFunctionParametersContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_arrowFunctionParameters
	return p
}

func InitEmptyArrowFunctionParametersContext(p *ArrowFunctionParametersContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_arrowFunctionParameters
}

func (*ArrowFunctionParametersContext) IsArrowFunctionParametersContext() {}

func NewArrowFunctionParametersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrowFunctionParametersContext {
	var p = new(ArrowFunctionParametersContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ServerScriptParserRULE_arrowFunctionParameters

	return p
}

func (s *ArrowFunctionParametersContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrowFunctionParametersContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ArrowFunctionParametersContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserOpenParen, 0)
}

func (s *ArrowFunctionParametersContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserCloseParen, 0)
}

func (s *ArrowFunctionParametersContext) FormalParameterList() IFormalParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFormalParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFormalParameterListContext)
}

func (s *ArrowFunctionParametersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrowFunctionParametersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrowFunctionParametersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.EnterArrowFunctionParameters(s)
	}
}

func (s *ArrowFunctionParametersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.ExitArrowFunctionParameters(s)
	}
}

func (s *ArrowFunctionParametersContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ServerScriptParserVisitor:
		return t.VisitArrowFunctionParameters(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ServerScriptParser) ArrowFunctionParameters() (localctx IArrowFunctionParametersContext) {
	localctx = NewArrowFunctionParametersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, ServerScriptParserRULE_arrowFunctionParameters)
	var _la int

	p.SetState(832)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ServerScriptParserAs, ServerScriptParserFrom, ServerScriptParserOf, ServerScriptParserAsync, ServerScriptParserYield, ServerScriptParserIdentifier:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(826)
			p.Identifier()
		}

	case ServerScriptParserOpenParen:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(827)
			p.Match(ServerScriptParserOpenParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(829)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&262688) != 0) || ((int64((_la-103)) & ^0x3f) == 0 && ((int64(1)<<(_la-103))&2106375) != 0) {
			{
				p.SetState(828)
				p.FormalParameterList()
			}

		}
		{
			p.SetState(831)
			p.Match(ServerScriptParserCloseParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAssignmentOperatorContext is an interface to support dynamic dispatch.
type IAssignmentOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MultiplyAssign() antlr.TerminalNode
	DivideAssign() antlr.TerminalNode
	ModulusAssign() antlr.TerminalNode
	PlusAssign() antlr.TerminalNode
	MinusAssign() antlr.TerminalNode
	LeftShiftArithmeticAssign() antlr.TerminalNode
	RightShiftArithmeticAssign() antlr.TerminalNode
	RightShiftLogicalAssign() antlr.TerminalNode
	BitAndAssign() antlr.TerminalNode
	BitXorAssign() antlr.TerminalNode
	BitOrAssign() antlr.TerminalNode
	PowerAssign() antlr.TerminalNode
	NullishCoalescingAssign() antlr.TerminalNode

	// IsAssignmentOperatorContext differentiates from other interfaces.
	IsAssignmentOperatorContext()
}

type AssignmentOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignmentOperatorContext() *AssignmentOperatorContext {
	var p = new(AssignmentOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_assignmentOperator
	return p
}

func InitEmptyAssignmentOperatorContext(p *AssignmentOperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_assignmentOperator
}

func (*AssignmentOperatorContext) IsAssignmentOperatorContext() {}

func NewAssignmentOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignmentOperatorContext {
	var p = new(AssignmentOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ServerScriptParserRULE_assignmentOperator

	return p
}

func (s *AssignmentOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignmentOperatorContext) MultiplyAssign() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserMultiplyAssign, 0)
}

func (s *AssignmentOperatorContext) DivideAssign() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserDivideAssign, 0)
}

func (s *AssignmentOperatorContext) ModulusAssign() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserModulusAssign, 0)
}

func (s *AssignmentOperatorContext) PlusAssign() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserPlusAssign, 0)
}

func (s *AssignmentOperatorContext) MinusAssign() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserMinusAssign, 0)
}

func (s *AssignmentOperatorContext) LeftShiftArithmeticAssign() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserLeftShiftArithmeticAssign, 0)
}

func (s *AssignmentOperatorContext) RightShiftArithmeticAssign() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserRightShiftArithmeticAssign, 0)
}

func (s *AssignmentOperatorContext) RightShiftLogicalAssign() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserRightShiftLogicalAssign, 0)
}

func (s *AssignmentOperatorContext) BitAndAssign() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserBitAndAssign, 0)
}

func (s *AssignmentOperatorContext) BitXorAssign() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserBitXorAssign, 0)
}

func (s *AssignmentOperatorContext) BitOrAssign() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserBitOrAssign, 0)
}

func (s *AssignmentOperatorContext) PowerAssign() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserPowerAssign, 0)
}

func (s *AssignmentOperatorContext) NullishCoalescingAssign() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserNullishCoalescingAssign, 0)
}

func (s *AssignmentOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignmentOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssignmentOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.EnterAssignmentOperator(s)
	}
}

func (s *AssignmentOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.ExitAssignmentOperator(s)
	}
}

func (s *AssignmentOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ServerScriptParserVisitor:
		return t.VisitAssignmentOperator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ServerScriptParser) AssignmentOperator() (localctx IAssignmentOperatorContext) {
	localctx = NewAssignmentOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, ServerScriptParserRULE_assignmentOperator)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(834)
		_la = p.GetTokenStream().LA(1)

		if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&2305561534236983296) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILiteralContext is an interface to support dynamic dispatch.
type ILiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NullLiteral() antlr.TerminalNode
	BooleanLiteral() antlr.TerminalNode
	StringLiteral() antlr.TerminalNode
	UndefinedLiteral() antlr.TerminalNode
	NaNLiteral() antlr.TerminalNode
	InfinityLiteral() antlr.TerminalNode
	TemplateStringLiteral() ITemplateStringLiteralContext
	BigintLiteral() IBigintLiteralContext
	RegularExpressionLiteral() antlr.TerminalNode
	NumericLiteral() INumericLiteralContext

	// IsLiteralContext differentiates from other interfaces.
	IsLiteralContext()
}

type LiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLiteralContext() *LiteralContext {
	var p = new(LiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_literal
	return p
}

func InitEmptyLiteralContext(p *LiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_literal
}

func (*LiteralContext) IsLiteralContext() {}

func NewLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LiteralContext {
	var p = new(LiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ServerScriptParserRULE_literal

	return p
}

func (s *LiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *LiteralContext) NullLiteral() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserNullLiteral, 0)
}

func (s *LiteralContext) BooleanLiteral() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserBooleanLiteral, 0)
}

func (s *LiteralContext) StringLiteral() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserStringLiteral, 0)
}

func (s *LiteralContext) UndefinedLiteral() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserUndefinedLiteral, 0)
}

func (s *LiteralContext) NaNLiteral() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserNaNLiteral, 0)
}

func (s *LiteralContext) InfinityLiteral() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserInfinityLiteral, 0)
}

func (s *LiteralContext) TemplateStringLiteral() ITemplateStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITemplateStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITemplateStringLiteralContext)
}

func (s *LiteralContext) BigintLiteral() IBigintLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBigintLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBigintLiteralContext)
}

func (s *LiteralContext) RegularExpressionLiteral() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserRegularExpressionLiteral, 0)
}

func (s *LiteralContext) NumericLiteral() INumericLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumericLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumericLiteralContext)
}

func (s *LiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.EnterLiteral(s)
	}
}

func (s *LiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.ExitLiteral(s)
	}
}

func (s *LiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ServerScriptParserVisitor:
		return t.VisitLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ServerScriptParser) Literal() (localctx ILiteralContext) {
	localctx = NewLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, ServerScriptParserRULE_literal)
	p.SetState(846)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ServerScriptParserNullLiteral:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(836)
			p.Match(ServerScriptParserNullLiteral)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ServerScriptParserBooleanLiteral:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(837)
			p.Match(ServerScriptParserBooleanLiteral)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ServerScriptParserStringLiteral:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(838)
			p.Match(ServerScriptParserStringLiteral)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ServerScriptParserUndefinedLiteral:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(839)
			p.Match(ServerScriptParserUndefinedLiteral)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ServerScriptParserNaNLiteral:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(840)
			p.Match(ServerScriptParserNaNLiteral)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ServerScriptParserInfinityLiteral:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(841)
			p.Match(ServerScriptParserInfinityLiteral)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ServerScriptParserBackTick:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(842)
			p.TemplateStringLiteral()
		}

	case ServerScriptParserBigHexIntegerLiteral, ServerScriptParserBigOctalIntegerLiteral, ServerScriptParserBigBinaryIntegerLiteral, ServerScriptParserBigDecimalIntegerLiteral:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(843)
			p.BigintLiteral()
		}

	case ServerScriptParserRegularExpressionLiteral:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(844)
			p.Match(ServerScriptParserRegularExpressionLiteral)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ServerScriptParserDecimalLiteral, ServerScriptParserExponentLiteral, ServerScriptParserHexIntegerLiteral, ServerScriptParserOctalIntegerLiteral, ServerScriptParserBinaryIntegerLiteral:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(845)
			p.NumericLiteral()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITemplateStringLiteralContext is an interface to support dynamic dispatch.
type ITemplateStringLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllBackTick() []antlr.TerminalNode
	BackTick(i int) antlr.TerminalNode
	AllTemplateStringAtom() []ITemplateStringAtomContext
	TemplateStringAtom(i int) ITemplateStringAtomContext

	// IsTemplateStringLiteralContext differentiates from other interfaces.
	IsTemplateStringLiteralContext()
}

type TemplateStringLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTemplateStringLiteralContext() *TemplateStringLiteralContext {
	var p = new(TemplateStringLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_templateStringLiteral
	return p
}

func InitEmptyTemplateStringLiteralContext(p *TemplateStringLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_templateStringLiteral
}

func (*TemplateStringLiteralContext) IsTemplateStringLiteralContext() {}

func NewTemplateStringLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TemplateStringLiteralContext {
	var p = new(TemplateStringLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ServerScriptParserRULE_templateStringLiteral

	return p
}

func (s *TemplateStringLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *TemplateStringLiteralContext) AllBackTick() []antlr.TerminalNode {
	return s.GetTokens(ServerScriptParserBackTick)
}

func (s *TemplateStringLiteralContext) BackTick(i int) antlr.TerminalNode {
	return s.GetToken(ServerScriptParserBackTick, i)
}

func (s *TemplateStringLiteralContext) AllTemplateStringAtom() []ITemplateStringAtomContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITemplateStringAtomContext); ok {
			len++
		}
	}

	tst := make([]ITemplateStringAtomContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITemplateStringAtomContext); ok {
			tst[i] = t.(ITemplateStringAtomContext)
			i++
		}
	}

	return tst
}

func (s *TemplateStringLiteralContext) TemplateStringAtom(i int) ITemplateStringAtomContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITemplateStringAtomContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITemplateStringAtomContext)
}

func (s *TemplateStringLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TemplateStringLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TemplateStringLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.EnterTemplateStringLiteral(s)
	}
}

func (s *TemplateStringLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.ExitTemplateStringLiteral(s)
	}
}

func (s *TemplateStringLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ServerScriptParserVisitor:
		return t.VisitTemplateStringLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ServerScriptParser) TemplateStringLiteral() (localctx ITemplateStringLiteralContext) {
	localctx = NewTemplateStringLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, ServerScriptParserRULE_templateStringLiteral)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(848)
		p.Match(ServerScriptParserBackTick)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(852)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == ServerScriptParserTemplateStringStartExpression || _la == ServerScriptParserTemplateStringAtom {
		{
			p.SetState(849)
			p.TemplateStringAtom()
		}

		p.SetState(854)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(855)
		p.Match(ServerScriptParserBackTick)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITemplateStringAtomContext is an interface to support dynamic dispatch.
type ITemplateStringAtomContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TemplateStringAtom() antlr.TerminalNode
	TemplateStringStartExpression() antlr.TerminalNode
	SingleExpression() ISingleExpressionContext
	TemplateCloseBrace() antlr.TerminalNode

	// IsTemplateStringAtomContext differentiates from other interfaces.
	IsTemplateStringAtomContext()
}

type TemplateStringAtomContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTemplateStringAtomContext() *TemplateStringAtomContext {
	var p = new(TemplateStringAtomContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_templateStringAtom
	return p
}

func InitEmptyTemplateStringAtomContext(p *TemplateStringAtomContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_templateStringAtom
}

func (*TemplateStringAtomContext) IsTemplateStringAtomContext() {}

func NewTemplateStringAtomContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TemplateStringAtomContext {
	var p = new(TemplateStringAtomContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ServerScriptParserRULE_templateStringAtom

	return p
}

func (s *TemplateStringAtomContext) GetParser() antlr.Parser { return s.parser }

func (s *TemplateStringAtomContext) TemplateStringAtom() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserTemplateStringAtom, 0)
}

func (s *TemplateStringAtomContext) TemplateStringStartExpression() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserTemplateStringStartExpression, 0)
}

func (s *TemplateStringAtomContext) SingleExpression() ISingleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *TemplateStringAtomContext) TemplateCloseBrace() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserTemplateCloseBrace, 0)
}

func (s *TemplateStringAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TemplateStringAtomContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TemplateStringAtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.EnterTemplateStringAtom(s)
	}
}

func (s *TemplateStringAtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.ExitTemplateStringAtom(s)
	}
}

func (s *TemplateStringAtomContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ServerScriptParserVisitor:
		return t.VisitTemplateStringAtom(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ServerScriptParser) TemplateStringAtom() (localctx ITemplateStringAtomContext) {
	localctx = NewTemplateStringAtomContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, ServerScriptParserRULE_templateStringAtom)
	p.SetState(862)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ServerScriptParserTemplateStringAtom:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(857)
			p.Match(ServerScriptParserTemplateStringAtom)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ServerScriptParserTemplateStringStartExpression:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(858)
			p.Match(ServerScriptParserTemplateStringStartExpression)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(859)
			p.singleExpression(0)
		}
		{
			p.SetState(860)
			p.Match(ServerScriptParserTemplateCloseBrace)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INumericLiteralContext is an interface to support dynamic dispatch.
type INumericLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DecimalLiteral() antlr.TerminalNode
	ExponentLiteral() antlr.TerminalNode
	HexIntegerLiteral() antlr.TerminalNode
	OctalIntegerLiteral() antlr.TerminalNode
	BinaryIntegerLiteral() antlr.TerminalNode

	// IsNumericLiteralContext differentiates from other interfaces.
	IsNumericLiteralContext()
}

type NumericLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNumericLiteralContext() *NumericLiteralContext {
	var p = new(NumericLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_numericLiteral
	return p
}

func InitEmptyNumericLiteralContext(p *NumericLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_numericLiteral
}

func (*NumericLiteralContext) IsNumericLiteralContext() {}

func NewNumericLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NumericLiteralContext {
	var p = new(NumericLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ServerScriptParserRULE_numericLiteral

	return p
}

func (s *NumericLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *NumericLiteralContext) DecimalLiteral() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserDecimalLiteral, 0)
}

func (s *NumericLiteralContext) ExponentLiteral() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserExponentLiteral, 0)
}

func (s *NumericLiteralContext) HexIntegerLiteral() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserHexIntegerLiteral, 0)
}

func (s *NumericLiteralContext) OctalIntegerLiteral() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserOctalIntegerLiteral, 0)
}

func (s *NumericLiteralContext) BinaryIntegerLiteral() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserBinaryIntegerLiteral, 0)
}

func (s *NumericLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NumericLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NumericLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.EnterNumericLiteral(s)
	}
}

func (s *NumericLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.ExitNumericLiteral(s)
	}
}

func (s *NumericLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ServerScriptParserVisitor:
		return t.VisitNumericLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ServerScriptParser) NumericLiteral() (localctx INumericLiteralContext) {
	localctx = NewNumericLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, ServerScriptParserRULE_numericLiteral)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(864)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-67)) & ^0x3f) == 0 && ((int64(1)<<(_la-67))&31) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBigintLiteralContext is an interface to support dynamic dispatch.
type IBigintLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BigDecimalIntegerLiteral() antlr.TerminalNode
	BigHexIntegerLiteral() antlr.TerminalNode
	BigOctalIntegerLiteral() antlr.TerminalNode
	BigBinaryIntegerLiteral() antlr.TerminalNode

	// IsBigintLiteralContext differentiates from other interfaces.
	IsBigintLiteralContext()
}

type BigintLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBigintLiteralContext() *BigintLiteralContext {
	var p = new(BigintLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_bigintLiteral
	return p
}

func InitEmptyBigintLiteralContext(p *BigintLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_bigintLiteral
}

func (*BigintLiteralContext) IsBigintLiteralContext() {}

func NewBigintLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BigintLiteralContext {
	var p = new(BigintLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ServerScriptParserRULE_bigintLiteral

	return p
}

func (s *BigintLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *BigintLiteralContext) BigDecimalIntegerLiteral() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserBigDecimalIntegerLiteral, 0)
}

func (s *BigintLiteralContext) BigHexIntegerLiteral() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserBigHexIntegerLiteral, 0)
}

func (s *BigintLiteralContext) BigOctalIntegerLiteral() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserBigOctalIntegerLiteral, 0)
}

func (s *BigintLiteralContext) BigBinaryIntegerLiteral() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserBigBinaryIntegerLiteral, 0)
}

func (s *BigintLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BigintLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BigintLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.EnterBigintLiteral(s)
	}
}

func (s *BigintLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.ExitBigintLiteral(s)
	}
}

func (s *BigintLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ServerScriptParserVisitor:
		return t.VisitBigintLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ServerScriptParser) BigintLiteral() (localctx IBigintLiteralContext) {
	localctx = NewBigintLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, ServerScriptParserRULE_bigintLiteral)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(866)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-72)) & ^0x3f) == 0 && ((int64(1)<<(_la-72))&15) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentifierNameContext is an interface to support dynamic dispatch.
type IIdentifierNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	ReservedWord() IReservedWordContext
	NaNLiteral() antlr.TerminalNode

	// IsIdentifierNameContext differentiates from other interfaces.
	IsIdentifierNameContext()
}

type IdentifierNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierNameContext() *IdentifierNameContext {
	var p = new(IdentifierNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_identifierName
	return p
}

func InitEmptyIdentifierNameContext(p *IdentifierNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_identifierName
}

func (*IdentifierNameContext) IsIdentifierNameContext() {}

func NewIdentifierNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierNameContext {
	var p = new(IdentifierNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ServerScriptParserRULE_identifierName

	return p
}

func (s *IdentifierNameContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierNameContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *IdentifierNameContext) ReservedWord() IReservedWordContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReservedWordContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReservedWordContext)
}

func (s *IdentifierNameContext) NaNLiteral() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserNaNLiteral, 0)
}

func (s *IdentifierNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.EnterIdentifierName(s)
	}
}

func (s *IdentifierNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.ExitIdentifierName(s)
	}
}

func (s *IdentifierNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ServerScriptParserVisitor:
		return t.VisitIdentifierName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ServerScriptParser) IdentifierName() (localctx IIdentifierNameContext) {
	localctx = NewIdentifierNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, ServerScriptParserRULE_identifierName)
	p.SetState(871)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 91, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(868)
			p.Identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(869)
			p.ReservedWord()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(870)
			p.Match(ServerScriptParserNaNLiteral)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentifierContext is an interface to support dynamic dispatch.
type IIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() antlr.TerminalNode
	Async() antlr.TerminalNode
	As() antlr.TerminalNode
	From() antlr.TerminalNode
	Yield() antlr.TerminalNode
	Of() antlr.TerminalNode

	// IsIdentifierContext differentiates from other interfaces.
	IsIdentifierContext()
}

type IdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierContext() *IdentifierContext {
	var p = new(IdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_identifier
	return p
}

func InitEmptyIdentifierContext(p *IdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_identifier
}

func (*IdentifierContext) IsIdentifierContext() {}

func NewIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierContext {
	var p = new(IdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ServerScriptParserRULE_identifier

	return p
}

func (s *IdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierContext) Identifier() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserIdentifier, 0)
}

func (s *IdentifierContext) Async() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserAsync, 0)
}

func (s *IdentifierContext) As() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserAs, 0)
}

func (s *IdentifierContext) From() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserFrom, 0)
}

func (s *IdentifierContext) Yield() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserYield, 0)
}

func (s *IdentifierContext) Of() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserOf, 0)
}

func (s *IdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.EnterIdentifier(s)
	}
}

func (s *IdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.ExitIdentifier(s)
	}
}

func (s *IdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ServerScriptParserVisitor:
		return t.VisitIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ServerScriptParser) Identifier() (localctx IIdentifierContext) {
	localctx = NewIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, ServerScriptParserRULE_identifier)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(873)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-103)) & ^0x3f) == 0 && ((int64(1)<<(_la-103))&2106375) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReservedWordContext is an interface to support dynamic dispatch.
type IReservedWordContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Keyword() IKeywordContext
	NullLiteral() antlr.TerminalNode
	BooleanLiteral() antlr.TerminalNode

	// IsReservedWordContext differentiates from other interfaces.
	IsReservedWordContext()
}

type ReservedWordContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReservedWordContext() *ReservedWordContext {
	var p = new(ReservedWordContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_reservedWord
	return p
}

func InitEmptyReservedWordContext(p *ReservedWordContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_reservedWord
}

func (*ReservedWordContext) IsReservedWordContext() {}

func NewReservedWordContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReservedWordContext {
	var p = new(ReservedWordContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ServerScriptParserRULE_reservedWord

	return p
}

func (s *ReservedWordContext) GetParser() antlr.Parser { return s.parser }

func (s *ReservedWordContext) Keyword() IKeywordContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeywordContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeywordContext)
}

func (s *ReservedWordContext) NullLiteral() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserNullLiteral, 0)
}

func (s *ReservedWordContext) BooleanLiteral() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserBooleanLiteral, 0)
}

func (s *ReservedWordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReservedWordContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReservedWordContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.EnterReservedWord(s)
	}
}

func (s *ReservedWordContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.ExitReservedWord(s)
	}
}

func (s *ReservedWordContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ServerScriptParserVisitor:
		return t.VisitReservedWord(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ServerScriptParser) ReservedWord() (localctx IReservedWordContext) {
	localctx = NewReservedWordContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, ServerScriptParserRULE_reservedWord)
	p.SetState(878)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ServerScriptParserBreak, ServerScriptParserDo, ServerScriptParserInstanceof, ServerScriptParserTypeof, ServerScriptParserCase, ServerScriptParserElse, ServerScriptParserNew, ServerScriptParserVar, ServerScriptParserLet, ServerScriptParserCatch, ServerScriptParserFinally, ServerScriptParserReturn, ServerScriptParserVoid, ServerScriptParserContinue, ServerScriptParserFor, ServerScriptParserSwitch, ServerScriptParserWhile, ServerScriptParserDebugger, ServerScriptParserFunction_, ServerScriptParserThis, ServerScriptParserWith, ServerScriptParserDefault, ServerScriptParserIf, ServerScriptParserThrow, ServerScriptParserDelete, ServerScriptParserIn, ServerScriptParserTry, ServerScriptParserAs, ServerScriptParserFrom, ServerScriptParserOf, ServerScriptParserClass, ServerScriptParserEnum, ServerScriptParserExtends, ServerScriptParserSuper, ServerScriptParserConst, ServerScriptParserExport, ServerScriptParserImport, ServerScriptParserAsync, ServerScriptParserSync, ServerScriptParserAwait, ServerScriptParserYield, ServerScriptParserImplements, ServerScriptParserPrivate, ServerScriptParserPublic, ServerScriptParserInterface, ServerScriptParserPackage, ServerScriptParserProtected, ServerScriptParserStatic:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(875)
			p.Keyword()
		}

	case ServerScriptParserNullLiteral:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(876)
			p.Match(ServerScriptParserNullLiteral)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ServerScriptParserBooleanLiteral:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(877)
			p.Match(ServerScriptParserBooleanLiteral)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKeywordContext is an interface to support dynamic dispatch.
type IKeywordContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Break() antlr.TerminalNode
	Do() antlr.TerminalNode
	Instanceof() antlr.TerminalNode
	Typeof() antlr.TerminalNode
	Case() antlr.TerminalNode
	Else() antlr.TerminalNode
	New() antlr.TerminalNode
	Var() antlr.TerminalNode
	Catch() antlr.TerminalNode
	Finally() antlr.TerminalNode
	Return() antlr.TerminalNode
	Void() antlr.TerminalNode
	Continue() antlr.TerminalNode
	For() antlr.TerminalNode
	Switch() antlr.TerminalNode
	While() antlr.TerminalNode
	Debugger() antlr.TerminalNode
	Function_() antlr.TerminalNode
	This() antlr.TerminalNode
	With() antlr.TerminalNode
	Default() antlr.TerminalNode
	If() antlr.TerminalNode
	Throw() antlr.TerminalNode
	Delete() antlr.TerminalNode
	In() antlr.TerminalNode
	Try() antlr.TerminalNode
	Class() antlr.TerminalNode
	Enum() antlr.TerminalNode
	Extends() antlr.TerminalNode
	Super() antlr.TerminalNode
	Const() antlr.TerminalNode
	Export() antlr.TerminalNode
	Import() antlr.TerminalNode
	Implements() antlr.TerminalNode
	Let() antlr.TerminalNode
	Private() antlr.TerminalNode
	Public() antlr.TerminalNode
	Interface() antlr.TerminalNode
	Package() antlr.TerminalNode
	Protected() antlr.TerminalNode
	Static() antlr.TerminalNode
	Yield() antlr.TerminalNode
	Async() antlr.TerminalNode
	Await() antlr.TerminalNode
	Sync() antlr.TerminalNode
	From() antlr.TerminalNode
	As() antlr.TerminalNode
	Of() antlr.TerminalNode

	// IsKeywordContext differentiates from other interfaces.
	IsKeywordContext()
}

type KeywordContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKeywordContext() *KeywordContext {
	var p = new(KeywordContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_keyword
	return p
}

func InitEmptyKeywordContext(p *KeywordContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_keyword
}

func (*KeywordContext) IsKeywordContext() {}

func NewKeywordContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KeywordContext {
	var p = new(KeywordContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ServerScriptParserRULE_keyword

	return p
}

func (s *KeywordContext) GetParser() antlr.Parser { return s.parser }

func (s *KeywordContext) Break() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserBreak, 0)
}

func (s *KeywordContext) Do() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserDo, 0)
}

func (s *KeywordContext) Instanceof() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserInstanceof, 0)
}

func (s *KeywordContext) Typeof() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserTypeof, 0)
}

func (s *KeywordContext) Case() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserCase, 0)
}

func (s *KeywordContext) Else() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserElse, 0)
}

func (s *KeywordContext) New() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserNew, 0)
}

func (s *KeywordContext) Var() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserVar, 0)
}

func (s *KeywordContext) Catch() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserCatch, 0)
}

func (s *KeywordContext) Finally() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserFinally, 0)
}

func (s *KeywordContext) Return() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserReturn, 0)
}

func (s *KeywordContext) Void() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserVoid, 0)
}

func (s *KeywordContext) Continue() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserContinue, 0)
}

func (s *KeywordContext) For() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserFor, 0)
}

func (s *KeywordContext) Switch() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserSwitch, 0)
}

func (s *KeywordContext) While() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserWhile, 0)
}

func (s *KeywordContext) Debugger() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserDebugger, 0)
}

func (s *KeywordContext) Function_() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserFunction_, 0)
}

func (s *KeywordContext) This() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserThis, 0)
}

func (s *KeywordContext) With() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserWith, 0)
}

func (s *KeywordContext) Default() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserDefault, 0)
}

func (s *KeywordContext) If() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserIf, 0)
}

func (s *KeywordContext) Throw() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserThrow, 0)
}

func (s *KeywordContext) Delete() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserDelete, 0)
}

func (s *KeywordContext) In() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserIn, 0)
}

func (s *KeywordContext) Try() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserTry, 0)
}

func (s *KeywordContext) Class() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserClass, 0)
}

func (s *KeywordContext) Enum() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserEnum, 0)
}

func (s *KeywordContext) Extends() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserExtends, 0)
}

func (s *KeywordContext) Super() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserSuper, 0)
}

func (s *KeywordContext) Const() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserConst, 0)
}

func (s *KeywordContext) Export() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserExport, 0)
}

func (s *KeywordContext) Import() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserImport, 0)
}

func (s *KeywordContext) Implements() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserImplements, 0)
}

func (s *KeywordContext) Let() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserLet, 0)
}

func (s *KeywordContext) Private() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserPrivate, 0)
}

func (s *KeywordContext) Public() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserPublic, 0)
}

func (s *KeywordContext) Interface() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserInterface, 0)
}

func (s *KeywordContext) Package() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserPackage, 0)
}

func (s *KeywordContext) Protected() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserProtected, 0)
}

func (s *KeywordContext) Static() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserStatic, 0)
}

func (s *KeywordContext) Yield() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserYield, 0)
}

func (s *KeywordContext) Async() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserAsync, 0)
}

func (s *KeywordContext) Await() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserAwait, 0)
}

func (s *KeywordContext) Sync() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserSync, 0)
}

func (s *KeywordContext) From() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserFrom, 0)
}

func (s *KeywordContext) As() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserAs, 0)
}

func (s *KeywordContext) Of() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserOf, 0)
}

func (s *KeywordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KeywordContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KeywordContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.EnterKeyword(s)
	}
}

func (s *KeywordContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.ExitKeyword(s)
	}
}

func (s *KeywordContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ServerScriptParserVisitor:
		return t.VisitKeyword(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ServerScriptParser) Keyword() (localctx IKeywordContext) {
	localctx = NewKeywordContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, ServerScriptParserRULE_keyword)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(880)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-76)) & ^0x3f) == 0 && ((int64(1)<<(_la-76))&281474976710655) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEosContext is an interface to support dynamic dispatch.
type IEosContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SemiColon() antlr.TerminalNode
	EOF() antlr.TerminalNode

	// IsEosContext differentiates from other interfaces.
	IsEosContext()
}

type EosContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEosContext() *EosContext {
	var p = new(EosContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_eos
	return p
}

func InitEmptyEosContext(p *EosContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ServerScriptParserRULE_eos
}

func (*EosContext) IsEosContext() {}

func NewEosContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EosContext {
	var p = new(EosContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ServerScriptParserRULE_eos

	return p
}

func (s *EosContext) GetParser() antlr.Parser { return s.parser }

func (s *EosContext) SemiColon() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserSemiColon, 0)
}

func (s *EosContext) EOF() antlr.TerminalNode {
	return s.GetToken(ServerScriptParserEOF, 0)
}

func (s *EosContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EosContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EosContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.EnterEos(s)
	}
}

func (s *EosContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ServerScriptParserListener); ok {
		listenerT.ExitEos(s)
	}
}

func (s *EosContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ServerScriptParserVisitor:
		return t.VisitEos(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ServerScriptParser) Eos() (localctx IEosContext) {
	localctx = NewEosContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, ServerScriptParserRULE_eos)
	p.SetState(886)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 93, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(882)
			p.Match(ServerScriptParserSemiColon)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(883)
			p.Match(ServerScriptParserEOF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(884)

		if !(p.lineTerminatorAhead()) {
			p.SetError(antlr.NewFailedPredicateException(p, "p.lineTerminatorAhead()", ""))
			goto errorExit
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		p.SetState(885)

		if !(p.closeBrace()) {
			p.SetError(antlr.NewFailedPredicateException(p, "p.closeBrace()", ""))
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

func (p *ServerScriptParser) Sempred(localctx antlr.RuleContext, ruleIndex, predIndex int) bool {
	switch ruleIndex {
	case 26:
		var t *ExpressionStatementContext = nil
		if localctx != nil {
			t = localctx.(*ExpressionStatementContext)
		}
		return p.ExpressionStatement_Sempred(t, predIndex)

	case 38:
		var t *ContinueStatementContext = nil
		if localctx != nil {
			t = localctx.(*ContinueStatementContext)
		}
		return p.ContinueStatement_Sempred(t, predIndex)

	case 39:
		var t *BreakStatementContext = nil
		if localctx != nil {
			t = localctx.(*BreakStatementContext)
		}
		return p.BreakStatement_Sempred(t, predIndex)

	case 40:
		var t *ReturnStatementContext = nil
		if localctx != nil {
			t = localctx.(*ReturnStatementContext)
		}
		return p.ReturnStatement_Sempred(t, predIndex)

	case 46:
		var t *ThrowStatementContext = nil
		if localctx != nil {
			t = localctx.(*ThrowStatementContext)
		}
		return p.ThrowStatement_Sempred(t, predIndex)

	case 63:
		var t *SingleExpressionContext = nil
		if localctx != nil {
			t = localctx.(*SingleExpressionContext)
		}
		return p.SingleExpression_Sempred(t, predIndex)

	case 78:
		var t *EosContext = nil
		if localctx != nil {
			t = localctx.(*EosContext)
		}
		return p.Eos_Sempred(t, predIndex)

	default:
		panic("No predicate with index: " + fmt.Sprint(ruleIndex))
	}
}

func (p *ServerScriptParser) ExpressionStatement_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 0:
		return p.notOpenBraceAndNotFunction()

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *ServerScriptParser) ContinueStatement_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 1:
		return p.notLineTerminator()

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *ServerScriptParser) BreakStatement_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 2:
		return p.notLineTerminator()

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *ServerScriptParser) ReturnStatement_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 3:
		return p.notLineTerminator()

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *ServerScriptParser) ThrowStatement_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 4:
		return p.notLineTerminator()

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *ServerScriptParser) SingleExpression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 5:
		return p.Precpred(p.GetParserRuleContext(), 20)

	case 6:
		return p.Precpred(p.GetParserRuleContext(), 19)

	case 7:
		return p.Precpred(p.GetParserRuleContext(), 18)

	case 8:
		return p.Precpred(p.GetParserRuleContext(), 17)

	case 9:
		return p.Precpred(p.GetParserRuleContext(), 16)

	case 10:
		return p.Precpred(p.GetParserRuleContext(), 15)

	case 11:
		return p.Precpred(p.GetParserRuleContext(), 14)

	case 12:
		return p.Precpred(p.GetParserRuleContext(), 13)

	case 13:
		return p.Precpred(p.GetParserRuleContext(), 12)

	case 14:
		return p.Precpred(p.GetParserRuleContext(), 11)

	case 15:
		return p.Precpred(p.GetParserRuleContext(), 10)

	case 16:
		return p.Precpred(p.GetParserRuleContext(), 9)

	case 17:
		return p.Precpred(p.GetParserRuleContext(), 8)

	case 18:
		return p.Precpred(p.GetParserRuleContext(), 34)

	case 19:
		return p.Precpred(p.GetParserRuleContext(), 33)

	case 20:
		return p.Precpred(p.GetParserRuleContext(), 32)

	case 21:
		return p.Precpred(p.GetParserRuleContext(), 29)

	case 22:
		return p.notLineTerminator()

	case 23:
		return p.Precpred(p.GetParserRuleContext(), 28)

	case 24:
		return p.notLineTerminator()

	case 25:
		return p.Precpred(p.GetParserRuleContext(), 7)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *ServerScriptParser) Eos_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 26:
		return p.lineTerminatorAhead()

	case 27:
		return p.closeBrace()

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}
